{"version":3,"file":"default-BqxrPpFl.js","sources":["../../../../node_modules/@vueuse/shared/index.mjs","../../../../node_modules/@vueuse/core/index.mjs","../../../../node_modules/@vueuse/components/index.mjs","../../../../components/app/Header/HeaderMenuLink/index.vue","../../../../components/icons/IconWrap.vue","../../../../components/icons/IconEarth.vue","../../../../enums/locales.ts","../../../../composables/useLocale.ts","../../../../store/theme.ts","../../../../components/app/Header/HeaderDesktop/HeaderDesktopLocale.vue","../../../../composables/useMenu.ts","../../../../components/app/Header/HeaderDesktop/index.vue","../../../../utils/user-actions.ts","../../../../store/menu.ts","../../../../components/app/Header/HeaderMobile/HeaderMobileBurger.vue","../../../../components/app/Header/HeaderMobile/HeaderMobileLocale.vue","../../../../components/app/Header/HeaderMobile/HeaderMobileMenu.vue","../../../../components/app/Header/HeaderMobile/index.vue","../../../../components/app/Header/Header.vue","../../../../components/icons/IconDownloadWindows.vue","../../../../components/icons/IconDownloadMacOs.vue","../../../../components/icons/IconDownloadAppStore.vue","../../../../components/icons/IconDownloadGooglePlay.vue","../../../../components/app/Footer/Footer.vue","../../../../composables/useDarkTheme.ts","../../../../composables/useMobileMenu.ts","../../../../layouts/default.vue"],"sourcesContent":["import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? void 0 : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? void 0 : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, notNullish, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, tryOnBeforeUnmount, identity, isDef, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, isVue2, readonly, nextTick, reactive, markRaw, unref, getCurrentScope, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? void 0 : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true,\n    triggerOnRemoval = false\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = ref();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  if (triggerOnRemoval) {\n    useMutationObserver(document, (mutations) => {\n      mutations.filter((m) => m.removedNodes.length).map((n) => Array.from(n.removedNodes)).flat().forEach((node) => {\n        if (node === activeElement.value)\n          trigger();\n      });\n    }, {\n      childList: true,\n      subtree: true\n    });\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  useEventListener(animate, \"finish\", () => {\n    var _a;\n    if (commitStyles)\n      (_a = animate.value) == null ? void 0 : _a.commitStyles();\n  });\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    var _a2;\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.addEventListener(\"ended\", stop));\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (e.button !== 0)\n      return;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener(target, \"dragenter\", (event) => {\n      var _a, _b;\n      const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i) => i.kind === \"file\" ? i.type : null).filter(notNullish);\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = unref(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  const lastEventId = shallowRef(null);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n      lastEventId.value = e.lastEventId;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close,\n    lastEventId\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n  return reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input && input.value) {\n      input.value = \"\";\n      trigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false, preventScroll = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus({ preventScroll });\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      index: gamepad.index,\n      connected: gamepad.connected,\n      mapping: gamepad.mapping,\n      timestamp: gamepad.timestamp,\n      vibrationActuator: gamepad.vibrationActuator,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  target = toRef(target);\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = shallowReactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) {\n      return \"deviceOrientation\";\n    }\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const currentResult = event.results[event.resultIndex];\n      const { transcript } = currentResult[0];\n      isFinal.value = currentResult.isFinal;\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a2;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  watch(textareaScrollHeight, () => {\n    var _a2;\n    return (_a2 = options == null ? void 0 : options.onResize) == null ? void 0 : _a2.call(options);\n  });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnBeforeUnmount(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n  watch([size.width, size.height, list, containerRef], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, containerRef, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => {\n    if (!window || !(\"Notification\" in window))\n      return false;\n    try {\n      new Notification(\"\");\n    } catch (e) {\n      return false;\n    }\n    return true;\n  });\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  watch(urlRef, open);\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps, localDeps) {\n  if (deps.length === 0 && localDeps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  const depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n    const str = fn.toString();\n    if (str.trim().startsWith(\"function\")) {\n      return str;\n    } else {\n      const name = fn.name;\n      return `const ${name} = ${str}`;\n    }\n  }).join(\";\");\n  const importString = `importScripts(${depsString});`;\n  return `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\n\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n  const blobCode = `${depsParser(deps, localDeps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    localDependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies, localDependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import { defineComponent, ref, h, watch, computed, reactive, shallowRef, nextTick, getCurrentInstance, onMounted, isVue2, watchEffect, toRefs } from 'vue-demi';\nimport { onClickOutside as onClickOutside$1, useActiveElement, useBattery, useBrowserLocation, useClipboard, useDark, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDocumentVisibility, useStorage as useStorage$1, isClient as isClient$1, useDraggable, useElementBounding, useElementSize as useElementSize$1, useElementVisibility as useElementVisibility$1, useEyeDropper, useFullscreen, useGeolocation, useIdle, useMouse, useMouseInElement, useMousePressed, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, usePointer, usePointerLock, usePreferredColorScheme, usePreferredContrast, usePreferredDark as usePreferredDark$1, usePreferredLanguages, usePreferredReducedMotion, useTimeAgo, useTimestamp, useVirtualList, useWindowFocus, useWindowSize } from '@vueuse/core';\nimport { toValue, isClient, noop, isObject, tryOnScopeDispose, isIOS, directiveHooks, pausableWatch, tryOnMounted, toRef, useToggle, notNullish, promiseTimeout, until, useDebounceFn, useThrottleFn } from '@vueuse/shared';\n\nconst OnClickOutside = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"OnClickOutside\",\n  props: [\"as\", \"options\"],\n  emits: [\"trigger\"],\n  setup(props, { slots, emit }) {\n    const target = ref();\n    onClickOutside$1(target, (e) => {\n      emit(\"trigger\", e);\n    }, props.options);\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default());\n    };\n  }\n});\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement))) {\n          handler(event);\n        }\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nconst vOnClickOutside = {\n  [directiveHooks.mounted](el, binding) {\n    const capture = !binding.modifiers.bubble;\n    if (typeof binding.value === \"function\") {\n      el.__onClickOutside_stop = onClickOutside(el, binding.value, { capture });\n    } else {\n      const [handler, options] = binding.value;\n      el.__onClickOutside_stop = onClickOutside(el, handler, Object.assign({ capture }, options));\n    }\n  },\n  [directiveHooks.unmounted](el) {\n    el.__onClickOutside_stop();\n  }\n};\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\n\nconst vOnKeyStroke = {\n  [directiveHooks.mounted](el, binding) {\n    var _a, _b;\n    const keys = (_b = (_a = binding.arg) == null ? void 0 : _a.split(\",\")) != null ? _b : true;\n    if (typeof binding.value === \"function\") {\n      onKeyStroke(keys, binding.value, {\n        target: el\n      });\n    } else {\n      const [handler, options] = binding.value;\n      onKeyStroke(keys, handler, {\n        target: el,\n        ...options\n      });\n    }\n  }\n};\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  let startTimestamp;\n  let hasLongPressed = false;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n    startTimestamp = void 0;\n    hasLongPressed = false;\n  }\n  function onRelease(ev) {\n    var _a2, _b2, _c;\n    const [_startTimestamp, _posStart, _hasLongPressed] = [startTimestamp, posStart, hasLongPressed];\n    clear();\n    if (!(options == null ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp)\n      return;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - _posStart.x;\n    const dy = ev.y - _posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    options.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    startTimestamp = ev.timeStamp;\n    timeout = setTimeout(\n      () => {\n        hasLongPressed = true;\n        handler(ev);\n      },\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nconst OnLongPress = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"OnLongPress\",\n  props: [\"as\", \"options\"],\n  emits: [\"trigger\"],\n  setup(props, { slots, emit }) {\n    const target = ref();\n    onLongPress(\n      target,\n      (e) => {\n        emit(\"trigger\", e);\n      },\n      props.options\n    );\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default());\n    };\n  }\n});\n\nconst vOnLongPress = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\")\n      onLongPress(el, binding.value, { modifiers: binding.modifiers });\n    else\n      onLongPress(el, ...binding.value);\n  }\n};\n\nconst UseActiveElement = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseActiveElement\",\n  setup(props, { slots }) {\n    const data = reactive({\n      element: useActiveElement()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseBattery = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseBattery\",\n  setup(props, { slots }) {\n    const data = reactive(useBattery(props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseBrowserLocation = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseBrowserLocation\",\n  setup(props, { slots }) {\n    const data = reactive(useBrowserLocation());\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseClipboard = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseClipboard\",\n  props: [\n    \"source\",\n    \"read\",\n    \"navigator\",\n    \"copiedDuring\",\n    \"legacy\"\n  ],\n  setup(props, { slots }) {\n    const data = reactive(useClipboard(props));\n    return () => {\n      var _a;\n      return (_a = slots.default) == null ? void 0 : _a.call(slots, data);\n    };\n  }\n});\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? void 0 : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nconst UseColorMode = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseColorMode\",\n  props: [\"selector\", \"attribute\", \"modes\", \"onChanged\", \"storageKey\", \"storage\", \"emitAuto\"],\n  setup(props, { slots }) {\n    const mode = useColorMode(props);\n    const data = reactive({\n      mode,\n      system: mode.system,\n      store: mode.store\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDark = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDark\",\n  props: [\"selector\", \"attribute\", \"valueDark\", \"valueLight\", \"onChanged\", \"storageKey\", \"storage\"],\n  setup(props, { slots }) {\n    const isDark = useDark(props);\n    const data = reactive({\n      isDark,\n      toggleDark: useToggle(isDark)\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDeviceMotion = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDeviceMotion\",\n  setup(props, { slots }) {\n    const data = reactive(useDeviceMotion());\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDeviceOrientation = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDeviceOrientation\",\n  setup(props, { slots }) {\n    const data = reactive(useDeviceOrientation());\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDevicePixelRatio = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDevicePixelRatio\",\n  setup(props, { slots }) {\n    const data = reactive({\n      pixelRatio: useDevicePixelRatio()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDevicesList = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDevicesList\",\n  props: [\"onUpdated\", \"requestPermissions\", \"constraints\"],\n  setup(props, { slots }) {\n    const data = reactive(useDevicesList(props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDocumentVisibility = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDocumentVisibility\",\n  setup(props, { slots }) {\n    const data = reactive({\n      visibility: useDocumentVisibility()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseDraggable = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseDraggable\",\n  props: [\n    \"storageKey\",\n    \"storageType\",\n    \"initialValue\",\n    \"exact\",\n    \"preventDefault\",\n    \"stopPropagation\",\n    \"pointerTypes\",\n    \"as\",\n    \"handle\",\n    \"axis\",\n    \"onStart\",\n    \"onMove\",\n    \"onEnd\",\n    \"disabled\"\n  ],\n  setup(props, { slots }) {\n    const target = ref();\n    const handle = computed(() => {\n      var _a;\n      return (_a = props.handle) != null ? _a : target.value;\n    });\n    const disabled = computed(() => !!props.disabled);\n    const storageValue = props.storageKey && useStorage$1(\n      props.storageKey,\n      toValue(props.initialValue) || { x: 0, y: 0 },\n      isClient$1 ? props.storageType === \"session\" ? sessionStorage : localStorage : void 0\n    );\n    const initialValue = storageValue || props.initialValue || { x: 0, y: 0 };\n    const onEnd = (position, event) => {\n      var _a;\n      (_a = props.onEnd) == null ? void 0 : _a.call(props, position, event);\n      if (!storageValue)\n        return;\n      storageValue.value.x = position.x;\n      storageValue.value.y = position.y;\n    };\n    const data = reactive(useDraggable(target, {\n      ...props,\n      handle,\n      initialValue,\n      onEnd,\n      disabled\n    }));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target, style: `touch-action:none;${data.style}` }, slots.default(data));\n    };\n  }\n});\n\nconst UseElementBounding = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseElementBounding\",\n  props: [\"box\", \"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(useElementBounding(target));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nconst vElementHover = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\") {\n      const isHovered = useElementHover(el);\n      watch(isHovered, (v) => binding.value(v));\n    }\n  }\n};\n\nconst UseElementSize = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseElementSize\",\n  props: [\"width\", \"height\", \"box\", \"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(useElementSize$1(target, { width: props.width, height: props.height }, { box: props.box }));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const rect = $elem.getBoundingClientRect();\n          width.value = rect.width;\n          height.value = rect.height;\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nconst vElementSize = {\n  [directiveHooks.mounted](el, binding) {\n    var _a;\n    const handler = typeof binding.value === \"function\" ? binding.value : (_a = binding.value) == null ? void 0 : _a[0];\n    const options = typeof binding.value === \"function\" ? [] : binding.value.slice(1);\n    const { width, height } = useElementSize(el, ...options);\n    watch([width, height], ([width2, height2]) => handler({ width: width2, height: height2 }));\n  }\n};\n\nconst UseElementVisibility = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseElementVisibility\",\n  props: [\"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive({\n      isVisible: useElementVisibility$1(target)\n    });\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst vElementVisibility = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\") {\n      const handler = binding.value;\n      const isVisible = useElementVisibility(el);\n      watch(isVisible, (v) => handler(v), { immediate: true });\n    } else {\n      const [handler, options] = binding.value;\n      const isVisible = useElementVisibility(el, options);\n      watch(isVisible, (v) => handler(v), { immediate: true });\n    }\n  }\n};\n\nconst UseEyeDropper = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseEyeDropper\",\n  props: {\n    sRGBHex: String\n  },\n  setup(props, { slots }) {\n    const data = reactive(useEyeDropper());\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseFullscreen = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseFullscreen\",\n  props: [\"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(useFullscreen(target));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nconst UseGeolocation = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseGeolocation\",\n  props: [\"enableHighAccuracy\", \"maximumAge\", \"timeout\", \"navigator\"],\n  setup(props, { slots }) {\n    const data = reactive(useGeolocation(props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseIdle = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseIdle\",\n  props: [\"timeout\", \"events\", \"listenForVisibilityChange\", \"initialState\"],\n  setup(props, { slots }) {\n    const data = reactive(useIdle(props.timeout, props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst UseImage = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseImage\",\n  props: [\n    \"src\",\n    \"srcset\",\n    \"sizes\",\n    \"as\",\n    \"alt\",\n    \"class\",\n    \"loading\",\n    \"crossorigin\",\n    \"referrerPolicy\"\n  ],\n  setup(props, { slots }) {\n    const data = reactive(useImage(props));\n    return () => {\n      if (data.isLoading && slots.loading)\n        return slots.loading(data);\n      else if (data.error && slots.error)\n        return slots.error(data.error);\n      if (slots.default)\n        return slots.default(data);\n      return h(props.as || \"img\", props);\n    };\n  }\n});\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c, _d;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n    const scrollContainer = ((_d = _element == null ? void 0 : _element.document) == null ? void 0 : _d.documentElement) || (_element == null ? void 0 : _element.documentElement) || _element;\n    if (x != null)\n      internalX.value = scrollContainer.scrollLeft;\n    if (y != null)\n      internalY.value = scrollContainer.scrollTop;\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst vInfiniteScroll = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\")\n      useInfiniteScroll(el, binding.value);\n    else\n      useInfiniteScroll(el, ...binding.value);\n  }\n};\n\nconst vIntersectionObserver = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\")\n      useIntersectionObserver(el, binding.value);\n    else\n      useIntersectionObserver(el, ...binding.value);\n  }\n};\n\nconst UseMouse = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseMouse\",\n  props: [\"touch\", \"resetOnTouchEnds\", \"initialValue\"],\n  setup(props, { slots }) {\n    const data = reactive(useMouse(props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseMouseInElement = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseMouseElement\",\n  props: [\"handleOutside\", \"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(useMouseInElement(target, props));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nconst UseMousePressed = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseMousePressed\",\n  props: [\"touch\", \"initialValue\", \"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(useMousePressed({ ...props, target }));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nconst UseNetwork = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseNetwork\",\n  setup(props, { slots }) {\n    const data = reactive(useNetwork());\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseNow = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseNow\",\n  props: [\"interval\"],\n  setup(props, { slots }) {\n    const data = reactive(useNow({ ...props, controls: true }));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseObjectUrl = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseObjectUrl\",\n  props: [\n    \"object\"\n  ],\n  setup(props, { slots }) {\n    const object = toRef(props, \"object\");\n    const url = useObjectUrl(object);\n    return () => {\n      if (slots.default && url.value)\n        return slots.default(url);\n    };\n  }\n});\n\nconst UseOffsetPagination = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseOffsetPagination\",\n  props: [\n    \"total\",\n    \"page\",\n    \"pageSize\",\n    \"onPageChange\",\n    \"onPageSizeChange\",\n    \"onPageCountChange\"\n  ],\n  emits: [\n    \"page-change\",\n    \"page-size-change\",\n    \"page-count-change\"\n  ],\n  setup(props, { slots, emit }) {\n    const data = reactive(useOffsetPagination({\n      ...props,\n      onPageChange(...args) {\n        var _a;\n        (_a = props.onPageChange) == null ? void 0 : _a.call(props, ...args);\n        emit(\"page-change\", ...args);\n      },\n      onPageSizeChange(...args) {\n        var _a;\n        (_a = props.onPageSizeChange) == null ? void 0 : _a.call(props, ...args);\n        emit(\"page-size-change\", ...args);\n      },\n      onPageCountChange(...args) {\n        var _a;\n        (_a = props.onPageCountChange) == null ? void 0 : _a.call(props, ...args);\n        emit(\"page-count-change\", ...args);\n      }\n    }));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseOnline = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseOnline\",\n  setup(props, { slots }) {\n    const data = reactive({\n      isOnline: useOnline()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePageLeave = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePageLeave\",\n  setup(props, { slots }) {\n    const data = reactive({\n      isLeft: usePageLeave()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePointer = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePointer\",\n  props: [\n    \"pointerTypes\",\n    \"initialValue\",\n    \"target\"\n  ],\n  setup(props, { slots }) {\n    const el = ref(null);\n    const data = reactive(usePointer({\n      ...props,\n      target: props.target === \"self\" ? el : defaultWindow\n    }));\n    return () => {\n      if (slots.default)\n        return slots.default(data, { ref: el });\n    };\n  }\n});\n\nconst UsePointerLock = /* #__PURE__ */ defineComponent({\n  name: \"UsePointerLock\",\n  props: [\"as\"],\n  setup(props, { slots }) {\n    const target = ref();\n    const data = reactive(usePointerLock(target));\n    return () => {\n      if (slots.default)\n        return h(props.as || \"div\", { ref: target }, slots.default(data));\n    };\n  }\n});\n\nconst UsePreferredColorScheme = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePreferredColorScheme\",\n  setup(props, { slots }) {\n    const data = reactive({\n      colorScheme: usePreferredColorScheme()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePreferredContrast = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePreferredContrast\",\n  setup(props, { slots }) {\n    const data = reactive({\n      contrast: usePreferredContrast()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePreferredDark = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePreferredDark\",\n  setup(props, { slots }) {\n    const data = reactive({\n      prefersDark: usePreferredDark$1()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePreferredLanguages = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePreferredLanguages\",\n  setup(props, { slots }) {\n    const data = reactive({\n      languages: usePreferredLanguages()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UsePreferredReducedMotion = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UsePreferredReducedMotion\",\n  setup(props, { slots }) {\n    const data = reactive({\n      motion: usePreferredReducedMotion()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nconst UseScreenSafeArea = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseScreenSafeArea\",\n  props: {\n    top: Boolean,\n    right: Boolean,\n    bottom: Boolean,\n    left: Boolean\n  },\n  setup(props, { slots }) {\n    const {\n      top,\n      right,\n      bottom,\n      left\n    } = useScreenSafeArea();\n    return () => {\n      if (slots.default) {\n        return h(\"div\", {\n          style: {\n            paddingTop: props.top ? top.value : \"\",\n            paddingRight: props.right ? right.value : \"\",\n            paddingBottom: props.bottom ? bottom.value : \"\",\n            paddingLeft: props.left ? left.value : \"\",\n            boxSizing: \"border-box\",\n            maxHeight: \"100vh\",\n            maxWidth: \"100vw\",\n            overflow: \"auto\"\n          }\n        }, slots.default());\n      }\n    };\n  }\n});\n\nconst vScroll = {\n  [directiveHooks.mounted](el, binding) {\n    if (typeof binding.value === \"function\") {\n      const handler = binding.value;\n      const state = useScroll(el, {\n        onScroll() {\n          handler(state);\n        },\n        onStop() {\n          handler(state);\n        }\n      });\n    } else {\n      const [handler, options] = binding.value;\n      const state = useScroll(el, {\n        ...options,\n        onScroll(e) {\n          var _a;\n          (_a = options.onScroll) == null ? void 0 : _a.call(options, e);\n          handler(state);\n        },\n        onStop(e) {\n          var _a;\n          (_a = options.onStop) == null ? void 0 : _a.call(options, e);\n          handler(state);\n        }\n      });\n    }\n  }\n};\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow = \"\";\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (ele.style.overflow !== \"hidden\")\n        initialOverflow = ele.style.overflow;\n      if (ele.style.overflow === \"hidden\")\n        return isLocked.value = true;\n      if (isLocked.value)\n        return ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = initialOverflow;\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else unlock();\n    }\n  });\n}\n\nfunction onScrollLock() {\n  let isMounted = false;\n  const state = ref(false);\n  return (el, binding) => {\n    state.value = binding.value;\n    if (isMounted)\n      return;\n    isMounted = true;\n    const isLocked = useScrollLock(el, binding.value);\n    watch(state, (v) => isLocked.value = v);\n  };\n}\nconst vScrollLock = onScrollLock();\n\nconst UseTimeAgo = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseTimeAgo\",\n  props: [\"time\", \"updateInterval\", \"max\", \"fullDateFormatter\", \"messages\", \"showSecond\"],\n  setup(props, { slots }) {\n    const data = reactive(useTimeAgo(() => props.time, { ...props, controls: true }));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseTimestamp = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseTimestamp\",\n  props: [\"immediate\", \"interval\", \"offset\"],\n  setup(props, { slots }) {\n    const data = reactive(useTimestamp({ ...props, controls: true }));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseVirtualList = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseVirtualList\",\n  props: [\n    \"list\",\n    \"options\",\n    \"height\"\n  ],\n  setup(props, { slots, expose }) {\n    const { list: listRef } = toRefs(props);\n    const { list, containerProps, wrapperProps, scrollTo } = useVirtualList(listRef, props.options);\n    expose({ scrollTo });\n    if (containerProps.style && typeof containerProps.style === \"object\" && !Array.isArray(containerProps.style))\n      containerProps.style.height = props.height || \"300px\";\n    return () => h(\"div\", { ...containerProps }, [\n      h(\"div\", { ...wrapperProps.value }, list.value.map((item) => h(\"div\", { style: { overflow: \"hidden\", height: item.height } }, slots.default ? slots.default(item) : \"Please set content!\")))\n    ]);\n  }\n});\n\nconst UseWindowFocus = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseWindowFocus\",\n  setup(props, { slots }) {\n    const data = reactive({\n      focused: useWindowFocus()\n    });\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nconst UseWindowSize = /* @__PURE__ */ /* #__PURE__ */ defineComponent({\n  name: \"UseWindowSize\",\n  props: [\"initialWidth\", \"initialHeight\"],\n  setup(props, { slots }) {\n    const data = reactive(useWindowSize(props));\n    return () => {\n      if (slots.default)\n        return slots.default(data);\n    };\n  }\n});\n\nexport { OnClickOutside, OnLongPress, UseActiveElement, UseBattery, UseBrowserLocation, UseClipboard, UseColorMode, UseDark, UseDeviceMotion, UseDeviceOrientation, UseDevicePixelRatio, UseDevicesList, UseDocumentVisibility, UseDraggable, UseElementBounding, UseElementSize, UseElementVisibility, UseEyeDropper, UseFullscreen, UseGeolocation, UseIdle, UseImage, UseMouse, UseMouseInElement, UseMousePressed, UseNetwork, UseNow, UseObjectUrl, UseOffsetPagination, UseOnline, UsePageLeave, UsePointer, UsePointerLock, UsePreferredColorScheme, UsePreferredContrast, UsePreferredDark, UsePreferredLanguages, UsePreferredReducedMotion, UseScreenSafeArea, UseTimeAgo, UseTimestamp, UseVirtualList, UseWindowFocus, UseWindowSize, vOnClickOutside as VOnClickOutside, vOnLongPress as VOnLongPress, vElementHover, vElementSize, vElementVisibility, vInfiniteScroll, vIntersectionObserver, vOnClickOutside, vOnKeyStroke, vOnLongPress, vScroll, vScrollLock };\n","<script setup lang=\"ts\">\nimport { ProductsEnum } from '~/enums/products'\nimport type { RoutesPathsEnum } from '~/enums/routes'\nimport type { TPlatformIcon } from '~/types/platforms'\n\nconst { title, slug, small, isDarkTheme, link } = defineProps<{\n  title: string\n  slug: string\n  small?: boolean\n  isDarkTheme?: boolean\n  link: RoutesPathsEnum\n}>()\n\nconst createMenuLink = (name: string): TPlatformIcon => ({\n  pale: {\n    src: `/images/platform/pale/${name}.svg`,\n    alt: name.charAt(0).toUpperCase() + name.slice(1),\n  },\n  color: {\n    src: `/images/platform/${name}.svg`,\n    alt: name.charAt(0).toUpperCase() + name.slice(1),\n  },\n})\n\nconst menuLinks: Record<ProductsEnum, TPlatformIcon> = {\n  [ProductsEnum.IOS]: createMenuLink('ios'),\n  [ProductsEnum.ANDROID]: createMenuLink('android'),\n  [ProductsEnum.MAC]: createMenuLink('mac'),\n  [ProductsEnum.WINDOWS]: createMenuLink('windows'),\n  [ProductsEnum.CHROME]: createMenuLink('chrome'),\n  [ProductsEnum.OPERA]: createMenuLink('opera'),\n  [ProductsEnum.YANDEX]: createMenuLink('yandex'),\n  [ProductsEnum.FIREFOX]: createMenuLink('firefox'),\n  [ProductsEnum.EDGE]: createMenuLink('edge'),\n  [ProductsEnum.LINUX]: createMenuLink('linux'),\n  [ProductsEnum.ROUTER]: createMenuLink('router'),\n}\n</script>\n\n<template>\n  <NuxtLinkLocale\n    :to=\"link\"\n    :class=\"{\n      'menu-link': true,\n      'menu-link--small': small,\n      'menu-link--dark': isDarkTheme,\n    }\"\n  >\n    <div class=\"menu-link__svg\">\n      <NuxtImg\n        :src=\"menuLinks[slug].pale.src\"\n        :alt=\"menuLinks[slug].pale.alt\"\n        width=\"50\"\n        height=\"51\"\n      />\n      <NuxtImg\n        :src=\"menuLinks[slug].color.src\"\n        :alt=\"menuLinks[slug].color.alt\"\n        width=\"50\"\n        height=\"51\"\n      />\n    </div>\n    <p>{{ title }}</p>\n  </NuxtLinkLocale>\n</template>\n\n<style scoped lang=\"scss\">\n.menu-link {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  column-gap: 10px;\n  min-width: 63px;\n  padding: 10px;\n  background-color: transparent;\n  border-radius: 10px;\n  cursor: pointer;\n  transition: var(--base-transition);\n\n  @media (min-width: 576px) {\n    min-width: 71px;\n  }\n\n  &:hover {\n    background-color: var(--gray-16);\n\n    .menu-link__svg {\n      img:first-child {\n        display: none;\n      }\n\n      img:last-child {\n        display: block;\n      }\n    }\n\n    p {\n      color: var(--orange-default);\n    }\n  }\n\n  &--dark {\n    &.menu-link {\n      p {\n        color: var(--gray-13);\n      }\n\n      &:hover {\n        background-color: var(--gray-6);\n\n        p {\n          color: var(--orange-default);\n        }\n      }\n    }\n\n    .menu-link__svg {\n      background-color: var(--gray-7);\n    }\n  }\n\n  &--small {\n    .menu-link__svg {\n      width: 30px;\n      height: 30px;\n      padding: 7px;\n      border-radius: 5px;\n\n      img {\n        width: 17px;\n        height: 17px;\n      }\n    }\n\n    p {\n      font-size: 14px;\n    }\n  }\n\n  &__svg {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n    width: 55px;\n    height: 55px;\n    padding: 16px 14px;\n    border-radius: 10px;\n    background: var(--gray-15);\n\n    img {\n      width: 25px;\n      height: 25px;\n\n      &:last-child {\n        display: none;\n      }\n    }\n  }\n\n  p {\n    font-size: 16px;\n    font-weight: 400;\n    color: var(--gray-5);\n  }\n}\n</style>\n","<script setup lang=\"ts\"></script>\n\n<template>\n  <div class=\"icon\">\n    <slot />\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.icon {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  width: 24px;\n  height: 24px;\n  flex-shrink: 0;\n\n  &:deep(svg) {\n    max-width: 100%;\n    height: auto;\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { computed } from 'vue'\n\nimport IconWrap from '~/components/icons/IconWrap.vue'\n\nconst props = defineProps<{\n  isDarkTheme?: boolean\n}>()\n\nconst fill = computed(() => (props.isDarkTheme ? '#FFFFFF' : '#2A2D30'))\n</script>\n\n<template>\n  <IconWrap>\n    <svg width=\"25\" height=\"24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d=\"M12.5 2.014c-5.523 0-10 4.477-10 10s4.477 10 10 10 10-4.477 10-10-4.477-10-10-10zm0 2c1.32 0 2.77 3.032 2.991 6.997l-5.97.012c.22-3.965 1.659-7.009 2.979-7.009zm-3.531.803c-.86 1.673-1.32 3.891-1.431 6.2l-2.98-.01c.298-2.725 2.133-5.01 4.411-6.19zm7.067.005c2.278 1.18 4.066 3.401 4.411 6.201l-2.979-.009c-.094-2.4-.625-4.51-1.432-6.192zM4.564 13.018l2.979-.025c.111 2.308.574 4.564 1.43 6.22a8.15 8.15 0 0 1-4.409-6.195zm4.941.008 5.97-.013c-.22 3.964-1.655 7.001-2.975 7.001s-2.775-3.023-2.995-6.988zm7.968-.01 2.966-.009c-.344 2.65-2.016 5.015-4.407 6.194.888-1.836 1.33-3.877 1.441-6.185z\"\n        :fill=\"fill\"\n      />\n    </svg>\n  </IconWrap>\n</template>\n\n<style scoped lang=\"scss\"></style>\n","export enum LocalesCodesEnum {\n  EN = 'en', // English\n  RU = 'ru', // Russian\n}\n","import { ref } from 'vue'\nimport { onClickOutside } from '@vueuse/core'\nimport { LocalesCodesEnum } from '~/enums/locales'\n\nconst localesList = {\n  [LocalesCodesEnum.EN]: {\n    code: LocalesCodesEnum.EN,\n    title: 'English',\n  },\n  [LocalesCodesEnum.RU]: {\n    code: LocalesCodesEnum.RU,\n    title: 'Russian',\n  },\n}\n\nexport const useLocale = (outsideRef) => {\n  const isLocale = ref(false)\n\n  const openLocales = () => {\n    isLocale.value = true\n  }\n\n  const closeLocales = () => {\n    isLocale.value = false\n  }\n\n  onClickOutside(outsideRef, () => {\n    closeLocales()\n  })\n\n  return {\n    localesList,\n    isLocale,\n    openLocales,\n    closeLocales,\n  }\n}\n","import { defineStore } from 'pinia'\n\ntype TThemeState = {\n  isDarkTheme: boolean\n}\n\nexport const useThemeStore = defineStore('theme', {\n  state: (): TThemeState => ({\n    isDarkTheme: false,\n  }),\n  getters: {},\n  actions: {\n    setDarkTheme() {\n      this.isDarkTheme = true\n    },\n    removeDarkTheme() {\n      this.isDarkTheme = false\n    },\n  },\n})\n","<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\nimport IconEarth from '~/components/icons/IconEarth.vue'\nimport { useLocale } from '~/composables/useLocale'\nimport type { LocalesCodesEnum } from '~/enums/locales'\nimport { useThemeStore } from '~/store/theme'\n\nconst localeDropdown = ref(null)\nconst { localesList, isLocale, openLocales, closeLocales } =\n  useLocale(localeDropdown)\nconst { locale, setLocale } = useI18n()\nconst themeStore = useThemeStore()\n\nconst onChangeLocale = (code: LocalesCodesEnum) => {\n  setLocale(code)\n  closeLocales()\n}\n</script>\n\n<template>\n  <div\n    class=\"header-lang\"\n    :class=\"{ 'header-lang--dark': themeStore.isDarkTheme }\"\n  >\n    <div\n      class=\"header-lang__current\"\n      :class=\"{ active: isLocale }\"\n      @click=\"openLocales\"\n    >\n      <IconEarth :is-dark-theme=\"themeStore.isDarkTheme\" />\n      {{ localesList[locale].title }}\n      <span\n        class=\"icon-chevron\"\n        :class=\"{ 'icon-chevron--dark': !themeStore.isDarkTheme }\"\n      />\n    </div>\n\n    <div v-if=\"isLocale\" ref=\"localeDropdown\" class=\"header-lang-list\">\n      <div\n        v-for=\"lang in Object.values(localesList)\"\n        :key=\"lang.code\"\n        class=\"header-lang-list__item\"\n        :class=\"{ active: lang.code === locale }\"\n        @click=\"onChangeLocale(lang.code)\"\n      >\n        {{ lang.title }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.header-lang {\n  position: relative;\n\n  &--dark {\n    .header-lang {\n      &__current {\n        &:hover,\n        &.active {\n          background-color: var(--gray-6);\n        }\n      }\n    }\n\n    .header-lang-list {\n      background-color: var(--gray-2);\n\n      &__item {\n        &.active {\n          background-color: var(--gray-6);\n        }\n      }\n    }\n  }\n\n  &__current {\n    display: flex;\n    align-items: center;\n    column-gap: 9px;\n    padding: 8px 16px;\n    border-radius: 20px;\n    background-color: transparent;\n    cursor: pointer;\n    user-select: none;\n    transition: var(--base-transition);\n\n    &:hover {\n      background-color: var(--gray-15);\n    }\n\n    &.active {\n      background-color: var(--gray-15);\n\n      .icon-chevron {\n        transform: rotate(180deg);\n      }\n    }\n  }\n\n  &-list {\n    position: absolute;\n    top: calc(100% + 8px);\n    left: 0;\n    width: 100%;\n    height: auto;\n    background-color: var(--white);\n    border-radius: 10px;\n    box-shadow: 0 4px 22px 0 rgba(24, 45, 78, 0.17);\n    overflow: hidden;\n\n    &__item {\n      font-size: 16px;\n      padding: 10px 20px;\n      transition: var(--base-transition);\n      cursor: pointer;\n\n      &.active {\n        font-weight: 500;\n        color: var(--orange-default);\n        background-color: var(--gray-15);\n      }\n    }\n  }\n}\n</style>\n","import { useI18n } from 'vue-i18n'\n\nimport { ProductsEnum } from '~/enums/products'\nimport { RoutesPathsEnum } from '~/enums/routes'\n\nexport const useMenu = () => {\n  const { t } = useI18n()\n\n  const menuList = [\n    {\n      title: t('menu.products.browser.title'),\n      links: [\n        {\n          title: t('menu.products.browser.firefox'),\n          slug: ProductsEnum.FIREFOX,\n          link: RoutesPathsEnum.EXTENSION_FIREFOX,\n        },\n        {\n          title: t('menu.products.browser.edge'),\n          slug: ProductsEnum.EDGE,\n          link: RoutesPathsEnum.EXTENSION_EDGE,\n        },\n        {\n          title: t('menu.products.browser.chrome'),\n          slug: ProductsEnum.CHROME,\n          link: RoutesPathsEnum.EXTENSION_CHROME,\n        },\n        {\n          title: t('menu.products.browser.opera'),\n          slug: ProductsEnum.OPERA,\n          link: RoutesPathsEnum.EXTENSION_OPERA,\n        },\n        {\n          title: t('menu.products.browser.yandex'),\n          slug: ProductsEnum.YANDEX,\n          link: RoutesPathsEnum.EXTENSION_YANDEX,\n        },\n      ],\n    },\n    {\n      title: t('menu.products.computer.title'),\n      links: [\n        {\n          title: t('menu.products.computer.windows'),\n          slug: ProductsEnum.WINDOWS,\n          link: RoutesPathsEnum.DESKTOP_WINDOWS,\n        },\n        {\n          title: t('menu.products.computer.mac'),\n          slug: ProductsEnum.MAC,\n          link: RoutesPathsEnum.DESKTOP_MAC,\n        },\n        {\n          title: t('menu.products.computer.linux'),\n          slug: ProductsEnum.LINUX,\n          link: RoutesPathsEnum.DESKTOP_LINUX,\n        },\n      ],\n    },\n    {\n      title: t('menu.products.mobile.title'),\n      links: [\n        {\n          title: t('menu.products.mobile.android'),\n          slug: ProductsEnum.ANDROID,\n          link: RoutesPathsEnum.MOBILE_ANDROID,\n        },\n        {\n          title: t('menu.products.mobile.ios'),\n          slug: ProductsEnum.IOS,\n          link: RoutesPathsEnum.MOBILE_IOS,\n        },\n      ],\n    },\n    {\n      title: t('menu.products.router.title'),\n      links: [\n        {\n          title: t('menu.products.router.router'),\n          slug: ProductsEnum.ROUTER,\n          link: '',\n        },\n      ],\n    },\n  ]\n\n  return { menuList }\n}\n","<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { vOnClickOutside } from '@vueuse/components'\n\nimport VButton from '~/ui/VButton.vue'\nimport HeaderMenuLink from '~/components/app/Header/HeaderMenuLink'\nimport HeaderDesktopLocale from '~/components/app/Header/HeaderDesktop/HeaderDesktopLocale.vue'\nimport { RoutesPathsEnum } from '~/enums/routes'\nimport { useMenu } from '~/composables/useMenu'\nimport { useThemeStore } from '~/store/theme'\n\nconst isDropdown = ref(false)\n\nconst { menuList } = useMenu()\nconst themeStore = useThemeStore()\n\nconst closeDropdown = () => {\n  isDropdown.value = false\n}\n</script>\n\n<template>\n  <div class=\"header-desktop\">\n    <div\n      class=\"header-menu\"\n      :class=\"{ 'header-menu--dark': themeStore.isDarkTheme }\"\n    >\n      <ul class=\"header-menu-list\">\n        <li\n          class=\"header-menu-list__item\"\n          :class=\"{ active: isDropdown }\"\n          @click=\"isDropdown = true\"\n        >\n          {{ $t('menu.products.title') }}\n          <span\n            class=\"icon-chevron\"\n            :class=\"{ 'icon-chevron--dark': !themeStore.isDarkTheme }\"\n          />\n        </li>\n      </ul>\n\n      <div\n        v-if=\"isDropdown\"\n        v-on-click-outside=\"closeDropdown\"\n        class=\"header-menu-dropdown\"\n      >\n        <div\n          v-for=\"menu in menuList\"\n          :key=\"menu.title\"\n          class=\"header-menu-dropdown__col\"\n        >\n          <h6>{{ menu.title }}</h6>\n          <HeaderMenuLink\n            v-for=\"link in menu.links\"\n            :key=\"link.slug\"\n            :title=\"link.title\"\n            :slug=\"link.slug\"\n            :link=\"link.link\"\n            :is-dark-theme=\"themeStore.isDarkTheme\"\n            small\n            @click=\"closeDropdown\"\n          />\n        </div>\n      </div>\n    </div>\n\n    <div class=\"header-donate\">\n      <HeaderDesktopLocale />\n\n      <NuxtLinkLocale :to=\"RoutesPathsEnum.DONATE\">\n        <VButton size=\"sm\">\n          <NuxtImg\n            src=\"/images/icons/icon-heart.svg\"\n            alt=\"Heart\"\n            width=\"19\"\n            height=\"18\"\n          />\n          {{ $t('header.button-donate') }}\n        </VButton>\n      </NuxtLinkLocale>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.header {\n  &-desktop {\n    display: none;\n\n    @media (min-width: 992px) {\n      display: flex;\n      align-items: center;\n      width: 100%;\n    }\n  }\n\n  &-menu {\n    position: relative;\n    margin-left: 180px;\n\n    &--dark {\n      .header-menu-dropdown {\n        background-color: var(--gray-2);\n\n        &__col h6 {\n          color: var(--gray-14);\n        }\n      }\n    }\n\n    &-list {\n      display: flex;\n      align-items: center;\n      list-style: none;\n\n      &__item {\n        display: flex;\n        align-items: center;\n        cursor: pointer;\n        user-select: none;\n\n        &.active {\n          .icon-chevron {\n            transform: rotate(180deg);\n          }\n        }\n      }\n    }\n\n    &-dropdown {\n      position: absolute;\n      top: calc(100% + 16px);\n      left: -235px;\n      display: flex;\n      justify-content: space-between;\n      width: 828px;\n      padding: 30px;\n      border-radius: 20px;\n      background-color: var(--white);\n      box-shadow: 0 4px 22px 0 rgba(24, 45, 78, 0.17);\n\n      @media (min-width: 1200px) {\n        left: -30px;\n      }\n\n      &__col {\n        width: 25%;\n\n        h6 {\n          font-family: var(--Montserrat);\n          font-size: 20px;\n          font-weight: 700;\n          line-height: 28px;\n          color: var(--gray-6);\n          text-transform: uppercase;\n          margin-bottom: 10px;\n        }\n      }\n    }\n  }\n\n  &-donate {\n    display: flex;\n    align-items: center;\n    column-gap: 20px;\n    margin-left: auto;\n  }\n}\n</style>\n","export const addNoScrollBody = (): void => {\n  document.body.classList.add('no-scroll')\n}\n\nexport const removeNoScrollBody = (): void => {\n  const noScroll = document.body.classList\n\n  if (noScroll.contains('no-scroll')) {\n    noScroll.remove('no-scroll')\n  }\n}\n","import { defineStore } from 'pinia'\n\nimport { addNoScrollBody, removeNoScrollBody } from '~/utils/user-actions'\n\ntype TMenuState = {\n  isMenuOpen: boolean\n}\n\nexport const useMenuStore = defineStore('menu', {\n  state: (): TMenuState => ({\n    isMenuOpen: false,\n  }),\n  getters: {},\n  actions: {\n    openMenu() {\n      this.isMenuOpen = true\n      addNoScrollBody()\n    },\n    closeMenu() {\n      this.isMenuOpen = false\n      removeNoScrollBody()\n    },\n  },\n})\n","<script setup lang=\"ts\">\nimport { useMenuStore } from '~/store/menu'\nimport { useThemeStore } from '~/store/theme'\n\nconst menuStore = useMenuStore()\nconst themeStore = useThemeStore()\n\nconst toggleMenu = () => {\n  if (menuStore.isMenuOpen) {\n    menuStore.closeMenu()\n  } else {\n    menuStore.openMenu()\n  }\n}\n</script>\n\n<template>\n  <div\n    class=\"burger-menu\"\n    :class=\"{ 'burger-menu--dark': themeStore.isDarkTheme }\"\n  >\n    <button\n      class=\"burger-menu__btn\"\n      :class=\"{ active: menuStore.isMenuOpen }\"\n      @click=\"toggleMenu\"\n    >\n      <span />\n      <span />\n      <span />\n    </button>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.burger-menu {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 30px;\n  width: 30px;\n\n  &--dark {\n    .burger-menu__btn {\n      span {\n        background-color: var(--white);\n      }\n    }\n  }\n\n  &__btn {\n    height: 30px;\n    width: 20px;\n    padding: 0;\n    cursor: pointer;\n    background-color: transparent;\n    border: none;\n    outline: none;\n    position: relative;\n\n    &.active {\n      span {\n        &:nth-child(1) {\n          animation: span-first-on 0.4s ease-in-out;\n          animation-fill-mode: forwards;\n        }\n\n        &:nth-child(2) {\n          animation: span-second-on 0.4s ease-in-out;\n          animation-fill-mode: forwards;\n        }\n\n        &:nth-child(3) {\n          animation: span-third-on 0.4s ease-in-out;\n          animation-fill-mode: forwards;\n        }\n      }\n    }\n\n    span {\n      position: absolute;\n      width: 100%;\n      height: 3px;\n      top: 50%;\n      left: 50%;\n      background-color: var(--gray-4);\n      border-radius: 2px;\n      overflow: hidden;\n      transition: all 0.25s linear;\n\n      &:nth-child(1) {\n        animation: span-first-off 0.4s ease-in-out;\n        animation-fill-mode: forwards;\n      }\n\n      &:nth-child(2) {\n        animation: span-second-off 0.4s ease-in-out;\n        animation-fill-mode: forwards;\n      }\n\n      &:nth-child(3) {\n        animation: span-third-off 0.4s ease-in-out;\n        animation-fill-mode: forwards;\n      }\n    }\n  }\n}\n\n@keyframes span-first-on {\n  0% {\n    transform: translate(-50%, -300%);\n  }\n  30% {\n    transform: translate(-50%, -50%);\n  }\n  100% {\n    transform: translate(-50%, -50%) rotate(-45deg);\n  }\n}\n\n@keyframes span-first-off {\n  0% {\n    transform: translate(-50%, -50%) rotate(-45deg);\n  }\n  30% {\n    transform: translate(-50%, -50%) rotate(0deg);\n  }\n  100% {\n    transform: translate(-50%, -300%);\n  }\n}\n\n@keyframes span-second-on {\n  0% {\n    transform: translate(-50%, -50%);\n  }\n  25% {\n    background-color: gray;\n  }\n  50% {\n    transform: translate(-50%, -50%) scale(1);\n  }\n  100% {\n    transform: translate(-150%, -50%) scale(0);\n  }\n}\n\n@keyframes span-second-off {\n  0% {\n    transform: translate(-150%, -50%) scale(0);\n  }\n  25% {\n    background-color: gray;\n  }\n  50% {\n    transform: translate(-50%, -50%) scale(1);\n  }\n  100% {\n    transform: translate(-50%, -50%);\n  }\n}\n\n@keyframes span-third-on {\n  0% {\n    transform: translate(-50%, 200%);\n  }\n  30% {\n    transform: translate(-50%, -50%);\n  }\n  100% {\n    transform: translate(-50%, -50%) rotate(45deg);\n  }\n}\n\n@keyframes span-third-off {\n  0% {\n    transform: translate(-50%, -50%) rotate(45deg);\n  }\n  30% {\n    transform: translate(-50%, -50%) rotate(0deg);\n  }\n  100% {\n    transform: translate(-50%, 200%);\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { ref } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\nimport { useLocale } from '~/composables/useLocale'\nimport type { LocalesCodesEnum } from '~/enums/locales'\nimport { useThemeStore } from '~/store/theme'\n\nconst localeDropdown = ref(null)\nconst { localesList, isLocale, openLocales, closeLocales } =\n  useLocale(localeDropdown)\nconst { locale, setLocale } = useI18n()\nconst themeStore = useThemeStore()\n\nconst onChangeLocale = (code: LocalesCodesEnum) => {\n  setLocale(code)\n  closeLocales()\n}\n</script>\n\n<template>\n  <div class=\"locale\" :class=\"{ 'locale--dark': themeStore.isDarkTheme }\">\n    <div class=\"locale-lang\">\n      {{ $t('locale.language') }}\n      <div class=\"locale-lang__current\" @click=\"openLocales\">\n        {{ localesList[locale].title }}\n        <span class=\"icon-chevron icon-chevron--orange icon-chevron--small\" />\n      </div>\n    </div>\n\n    <div v-if=\"isLocale\" ref=\"localeDropdown\" class=\"locale-list\">\n      <div class=\"locale-list__divider\" />\n      <div\n        v-for=\"lang in Object.values(localesList)\"\n        :key=\"lang.code\"\n        class=\"locale-list__item\"\n        :class=\"{ active: lang.code === locale }\"\n        @click=\"onChangeLocale(lang.code)\"\n      >\n        {{ lang.title }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.locale {\n  &--dark {\n    .locale-lang {\n      border-color: var(--gray-4);\n\n      &__current {\n        color: var(--gray-12);\n        background-color: var(--gray-5);\n      }\n    }\n\n    .locale-list {\n      background-color: var(--gray-2);\n\n      &__item {\n        &.active {\n          color: var(--gray-12);\n          background-color: var(--gray-6);\n        }\n      }\n    }\n  }\n\n  &-lang {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 50px;\n    padding: 10px 16px;\n    margin-bottom: 1px;\n    font-family: var(--Montserrat);\n    font-weight: 500;\n    border-bottom: 1px solid var(--gray-14);\n\n    &__current {\n      display: flex;\n      align-items: center;\n      column-gap: 5px;\n      padding: 5px 5px 5px 10px;\n      font-size: 12px;\n      color: var(--gray-9);\n      background-color: var(--gray-15);\n      border-radius: 10px;\n      cursor: pointer;\n      user-select: none;\n\n      .icon-chevron {\n        transform: rotate(-90deg);\n      }\n    }\n  }\n\n  &-list {\n    position: fixed;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    min-height: 100px;\n    font-family: var(--Montserrat);\n    font-size: 14px;\n    font-weight: 500;\n    text-align: center;\n    background-color: var(--white);\n    border-radius: 20px 20px 0 0;\n    overflow: hidden;\n    transition: var(--base-transition);\n    z-index: 5;\n\n    &__divider {\n      display: flex;\n      justify-content: center;\n      width: 100%;\n      padding: 8px 10px;\n\n      &::before {\n        content: '';\n        width: 36px;\n        height: 4px;\n        border-radius: 2px;\n        background-color: var(--gray-12);\n      }\n    }\n\n    &__item {\n      width: 100%;\n      height: 50px;\n      padding: 13px 10px;\n      cursor: pointer;\n\n      &.active {\n        font-weight: 500;\n        color: var(--orange-default);\n        background-color: var(--gray-15);\n      }\n    }\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport { useToggle } from '@vueuse/core'\n\nimport HeaderMenuLink from '~/components/app/Header/HeaderMenuLink'\nimport { useMenu } from '~/composables/useMenu'\nimport { useThemeStore } from '~/store/theme'\n\nconst [isDropdown, setDropdown] = useToggle()\nconst { menuList } = useMenu()\nconst themeStore = useThemeStore()\n</script>\n\n<template>\n  <div class=\"menu\" :class=\"{ 'menu--dark': themeStore.isDarkTheme }\">\n    <div\n      class=\"menu__subtitle\"\n      :class=\"{ active: isDropdown }\"\n      @click=\"setDropdown()\"\n    >\n      {{ $t('menu.products.title') }}\n      <span\n        class=\"icon-chevron\"\n        :class=\"{ 'icon-chevron--dark': !themeStore.isDarkTheme }\"\n      />\n    </div>\n\n    <div v-if=\"isDropdown\" class=\"menu-dropdown\">\n      <div\n        v-for=\"menu in menuList\"\n        :key=\"menu.title\"\n        class=\"menu-dropdown__col\"\n      >\n        <h6>{{ menu.title }}</h6>\n        <HeaderMenuLink\n          v-for=\"link in menu.links\"\n          :key=\"link.slug\"\n          :title=\"link.title\"\n          :slug=\"link.slug\"\n          :link=\"link.link\"\n          :is-dark-theme=\"themeStore.isDarkTheme\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.menu {\n  &--dark {\n    .menu__subtitle {\n      border-color: var(--gray-4);\n    }\n\n    .menu-dropdown {\n      background-color: var(--gray-2);\n\n      &__col {\n        h6 {\n          color: var(--gray-14);\n        }\n      }\n    }\n  }\n\n  &__subtitle {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    min-height: 50px;\n    padding: 10px 16px;\n    font-family: var(--Montserrat);\n    font-weight: 500;\n    border-bottom: 1px solid var(--gray-14);\n    cursor: pointer;\n    transition: transform var(--base-transition);\n\n    &.active {\n      border-bottom: none;\n\n      .icon-chevron {\n        transform: rotate(180deg);\n      }\n    }\n  }\n\n  &-dropdown {\n    display: grid;\n    grid-template-columns: 1fr;\n    gap: 20px 10px;\n    padding: 10px 16px;\n    background-color: var(--gray-17);\n\n    @media (min-width: 375px) {\n      grid-template-columns: repeat(2, 1fr);\n    }\n\n    @media (min-width: 768px) {\n      grid-template-columns: repeat(4, 1fr);\n      gap: 16px;\n    }\n\n    &__col {\n      h6 {\n        font-family: var(--Montserrat);\n        font-size: 20px;\n        font-weight: 700;\n        line-height: 28px;\n        color: var(--gray-6);\n        text-transform: uppercase;\n        margin-bottom: 10px;\n\n        @media (min-width: 375px) {\n          min-height: 56px;\n        }\n      }\n    }\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport VButton from '~/ui/VButton.vue'\nimport HeaderMobileBurger from '~/components/app/Header/HeaderMobile/HeaderMobileBurger.vue'\nimport HeaderMobileLocale from '~/components/app/Header/HeaderMobile/HeaderMobileLocale.vue'\nimport HeaderMobileMenu from '~/components/app/Header/HeaderMobile/HeaderMobileMenu.vue'\nimport { RoutesPathsEnum } from '~/enums/routes'\nimport { useMenuStore } from '~/store/menu'\nimport { useThemeStore } from '~/store/theme'\n\nconst menuStore = useMenuStore()\nconst themeStore = useThemeStore()\n</script>\n\n<template>\n  <div class=\"header-mobile\">\n    <NuxtLinkLocale :to=\"RoutesPathsEnum.DONATE\">\n      <VButton size=\"sm\">\n        <NuxtImg\n          src=\"/images/icons/icon-heart.svg\"\n          alt=\"Heart\"\n          width=\"19\"\n          height=\"18\"\n        />\n        {{ $t('header.button-donate') }}\n      </VButton>\n    </NuxtLinkLocale>\n\n    <HeaderMobileBurger />\n\n    <div\n      v-if=\"menuStore.isMenuOpen\"\n      class=\"header-tablet\"\n      :class=\"{ 'header-tablet--dark': themeStore.isDarkTheme }\"\n    >\n      <div class=\"header-tablet__support\">\n        <h6>{{ $t('header.support.title') }}</h6>\n        <p>{{ $t('header.support.text') }}</p>\n        <NuxtLinkLocale :to=\"RoutesPathsEnum.DONATE\">\n          <VButton>\n            <NuxtImg\n              src=\"/images/icons/icon-heart.svg\"\n              alt=\"Heart\"\n              width=\"19\"\n              height=\"18\"\n            />\n            {{ $t('header.button-donate') }}\n          </VButton>\n        </NuxtLinkLocale>\n      </div>\n\n      <div class=\"header-tablet__content\">\n        <HeaderMobileLocale />\n\n        <HeaderMobileMenu />\n\n        <div class=\"header-tablet__links\">\n          <NuxtLinkLocale :to=\"RoutesPathsEnum.POLICY\">\n            {{ $t('header.links.privacy') }}\n          </NuxtLinkLocale>\n          <NuxtLinkLocale :to=\"RoutesPathsEnum.TERMS\">\n            {{ $t('header.links.terms') }}\n          </NuxtLinkLocale>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped lang=\"scss\">\n.header {\n  &-mobile {\n    display: flex;\n    align-items: center;\n    column-gap: 20px;\n    margin-left: auto;\n\n    @media (min-width: 992px) {\n      display: none;\n    }\n  }\n\n  &-tablet {\n    position: fixed;\n    top: 60px;\n    left: 0;\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    height: calc(100svh - 60px);\n    background-color: var(--white);\n    overflow-y: auto;\n\n    &--dark {\n      background-color: var(--gray-1);\n\n      .header-tablet__content,\n      .header-tablet__links {\n        background-color: var(--gray-2);\n      }\n    }\n\n    &__support {\n      padding: 10px 16px 0;\n      margin-bottom: 30px;\n      text-align: center;\n\n      h6 {\n        font-family: var(--Montserrat);\n        font-size: 20px;\n        font-weight: 600;\n        margin-bottom: 5px;\n      }\n\n      p {\n        margin-bottom: 10px;\n      }\n    }\n\n    &__content {\n      display: flex;\n      flex-direction: column;\n      height: 100%;\n      background-color: var(--gray-17);\n      border-radius: 20px 20px 0 0;\n    }\n\n    &__links {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n      padding: 10px 0;\n      margin-top: auto;\n      background-color: var(--gray-17);\n\n      a {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 50%;\n        height: 30px;\n        padding: 10px 0;\n        color: var(--orange-default);\n        font-family: var(--Montserrat);\n        font-size: 14px;\n        font-weight: 600;\n      }\n    }\n  }\n}\n</style>\n","<script setup lang=\"ts\">\nimport HeaderDesktop from '~/components/app/Header/HeaderDesktop'\nimport HeaderMobile from '~/components/app/Header/HeaderMobile'\nimport { RoutesPathsEnum } from '~/enums/routes'\nimport { useThemeStore } from '~/store/theme'\n\nconst themeStore = useThemeStore()\n</script>\n\n<template>\n  <header class=\"header\" :class=\"{ 'header--dark': themeStore.isDarkTheme }\">\n    <div class=\"header__content\">\n      <NuxtLinkLocale :to=\"RoutesPathsEnum.MAIN\">\n        <NuxtImg\n          v-if=\"themeStore.isDarkTheme\"\n          src=\"/images/logo-white.svg\"\n          alt=\"Logo\"\n          width=\"156\"\n          height=\"44\"\n        />\n        <NuxtImg\n          v-else\n          src=\"/images/logo.svg\"\n          alt=\"Logo\"\n          width=\"156\"\n          height=\"44\"\n        />\n      </NuxtLinkLocale>\n\n      <HeaderDesktop />\n      <HeaderMobile />\n    </div>\n  </header>\n</template>\n\n<style scoped lang=\"scss\">\n.header {\n  position: fixed;\n  top: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n  width: 100%;\n  height: var(--header-height);\n  font-size: 16px;\n  color: var(--gray-4);\n  background-color: var(--white);\n  border-bottom: 1px solid #e7eaed;\n  z-index: 10;\n\n  &--dark {\n    color: var(--white);\n    background-color: var(--gray-1);\n    border-bottom: none;\n  }\n\n  &__content {\n    display: flex;\n    align-items: center;\n    width: 100%;\n    max-width: 1332px;\n    margin: 0 auto;\n    padding: 0 16px;\n    column-gap: 20px;\n  }\n}\n</style>\n","<script setup lang=\"ts\"></script>\n\n<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"158\"\n    height=\"56\"\n    viewBox=\"0 0 158 56\"\n    fill=\"none\"\n  >\n    <path\n      d=\"M0 7.55078C0 3.68479 3.13401 0.550781 7 0.550781H151C154.866 0.550781 158 3.68479 158 7.55078V48.5508C158 52.4168 154.866 55.5508 151 55.5508H7C3.134 55.5508 0 52.4168 0 48.5508V7.55078Z\"\n      stroke=\"#0A0A0B\"\n    />\n    <path\n      d=\"M51.4805 29.0731H36.3589V39.4615L51.4805 41.5508V29.0731Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M35.3833 29.0731H24.1641V37.7785L35.3833 39.328V29.0731Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M51.4805 15.5508L36.3589 17.6052V28.1445H51.4805V15.5508Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M35.3833 17.7387L24.1641 19.2651V28.1445H35.3833V17.7387Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M65.0332 17.1719V19.7012C64.9518 19.8216 64.8118 19.9551 64.6133 20.1016C64.4147 20.248 64.1478 20.3766 63.8125 20.4873C63.4772 20.5947 63.0605 20.6484 62.5625 20.6484C62.1458 20.6484 61.7633 20.5736 61.415 20.4238C61.0667 20.2741 60.764 20.0576 60.5068 19.7744C60.2529 19.488 60.056 19.1445 59.916 18.7441C59.7793 18.3438 59.7109 17.8945 59.7109 17.3965V16.5371C59.7109 16.0488 59.7744 15.6094 59.9014 15.2188C60.0283 14.8249 60.2122 14.488 60.4531 14.208C60.694 13.9281 60.9837 13.7148 61.3223 13.5684C61.6641 13.4186 62.0465 13.3438 62.4697 13.3438C62.9971 13.3438 63.4414 13.4349 63.8027 13.6172C64.1641 13.7995 64.4456 14.0501 64.6475 14.3691C64.8525 14.6849 64.9795 15.043 65.0283 15.4434H64.4277C64.3822 15.1602 64.2878 14.8997 64.1445 14.6621C64.0013 14.4212 63.793 14.2275 63.5195 14.0811C63.2493 13.9346 62.8994 13.8613 62.4697 13.8613C62.1247 13.8613 61.8171 13.9248 61.5469 14.0518C61.2799 14.1787 61.0553 14.3594 60.873 14.5938C60.6908 14.8281 60.5524 15.1097 60.458 15.4385C60.3636 15.764 60.3164 16.127 60.3164 16.5273V17.3965C60.3164 17.8132 60.3685 18.1891 60.4727 18.5244C60.5801 18.8597 60.7331 19.1478 60.9316 19.3887C61.1302 19.6296 61.3678 19.8151 61.6445 19.9453C61.9212 20.0723 62.2288 20.1357 62.5674 20.1357C62.9287 20.1357 63.2363 20.1016 63.4902 20.0332C63.7441 19.9648 63.9476 19.8835 64.1006 19.7891C64.2568 19.6914 64.3691 19.6003 64.4375 19.5156V17.6846H62.5283V17.1719H65.0332Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M68.6562 20.6484C68.3112 20.6484 67.9938 20.585 67.7041 20.458C67.4176 20.3311 67.167 20.152 66.9521 19.9209C66.7406 19.6898 66.5762 19.4163 66.459 19.1006C66.3451 18.7816 66.2881 18.4333 66.2881 18.0557V17.8457C66.2881 17.4388 66.3483 17.071 66.4688 16.7422C66.5892 16.4134 66.7552 16.1318 66.9668 15.8975C67.1784 15.6631 67.4193 15.484 67.6895 15.3604C67.9629 15.2334 68.2493 15.1699 68.5488 15.1699C68.8841 15.1699 69.182 15.2301 69.4424 15.3506C69.7028 15.4678 69.9209 15.6354 70.0967 15.8535C70.2757 16.0684 70.4108 16.3239 70.502 16.6201C70.5931 16.9131 70.6387 17.237 70.6387 17.5918V17.9482H66.6396V17.4502H70.0576V17.3818C70.0511 17.0856 69.9909 16.8089 69.877 16.5518C69.7663 16.2913 69.6003 16.0798 69.3789 15.917C69.1576 15.7542 68.8809 15.6729 68.5488 15.6729C68.3014 15.6729 68.0736 15.7249 67.8652 15.8291C67.6602 15.9333 67.4827 16.083 67.333 16.2783C67.1865 16.4704 67.0726 16.6999 66.9912 16.9668C66.9131 17.2305 66.874 17.5234 66.874 17.8457V18.0557C66.874 18.3486 66.9163 18.6221 67.001 18.876C67.0889 19.1266 67.2126 19.348 67.3721 19.54C67.5348 19.7321 67.7269 19.8818 67.9482 19.9893C68.1696 20.0967 68.4137 20.1504 68.6807 20.1504C68.9932 20.1504 69.2699 20.0934 69.5107 19.9795C69.7516 19.8623 69.9681 19.6784 70.1602 19.4277L70.5264 19.7109C70.4124 19.8802 70.2692 20.0365 70.0967 20.1797C69.9274 20.3229 69.724 20.4368 69.4863 20.5215C69.2487 20.6061 68.972 20.6484 68.6562 20.6484Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M73.7881 15.2676V15.7461H71.1416V15.2676H73.7881ZM72.1133 13.9102H72.6943V19.2666C72.6943 19.5107 72.7269 19.6947 72.792 19.8184C72.8571 19.9421 72.9417 20.0251 73.0459 20.0674C73.1501 20.1097 73.2624 20.1309 73.3828 20.1309C73.4707 20.1309 73.5553 20.126 73.6367 20.1162C73.7181 20.1032 73.7913 20.0902 73.8564 20.0771L73.8809 20.5703C73.8092 20.5931 73.7165 20.611 73.6025 20.624C73.4886 20.6403 73.3747 20.6484 73.2607 20.6484C73.0361 20.6484 72.8376 20.6077 72.665 20.5264C72.4925 20.4417 72.3574 20.2985 72.2598 20.0967C72.1621 19.8916 72.1133 19.6133 72.1133 19.2617V13.9102Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M78.1045 15.2676V20.5508H77.5234V15.2676H78.1045ZM77.4209 13.7393C77.4209 13.6286 77.4551 13.5358 77.5234 13.4609C77.5951 13.3828 77.6927 13.3438 77.8164 13.3438C77.9401 13.3438 78.0378 13.3828 78.1094 13.4609C78.1842 13.5358 78.2217 13.6286 78.2217 13.7393C78.2217 13.8467 78.1842 13.9395 78.1094 14.0176C78.0378 14.0924 77.9401 14.1299 77.8164 14.1299C77.6927 14.1299 77.5951 14.0924 77.5234 14.0176C77.4551 13.9395 77.4209 13.8467 77.4209 13.7393Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M81.6982 15.2676V15.7461H79.0518V15.2676H81.6982ZM80.0234 13.9102H80.6045V19.2666C80.6045 19.5107 80.637 19.6947 80.7021 19.8184C80.7673 19.9421 80.8519 20.0251 80.9561 20.0674C81.0602 20.1097 81.1725 20.1309 81.293 20.1309C81.3809 20.1309 81.4655 20.126 81.5469 20.1162C81.6283 20.1032 81.7015 20.0902 81.7666 20.0771L81.791 20.5703C81.7194 20.5931 81.6266 20.611 81.5127 20.624C81.3988 20.6403 81.2848 20.6484 81.1709 20.6484C80.9463 20.6484 80.7477 20.6077 80.5752 20.5264C80.4027 20.4417 80.2676 20.2985 80.1699 20.0967C80.0723 19.8916 80.0234 19.6133 80.0234 19.2617V13.9102Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M85.043 17.9922V17.8311C85.043 17.4469 85.0983 17.0921 85.209 16.7666C85.3197 16.4411 85.4775 16.1595 85.6826 15.9219C85.891 15.6842 86.14 15.5003 86.4297 15.3701C86.7194 15.2367 87.0417 15.1699 87.3965 15.1699C87.7546 15.1699 88.0785 15.2367 88.3682 15.3701C88.6579 15.5003 88.9069 15.6842 89.1152 15.9219C89.3236 16.1595 89.4831 16.4411 89.5938 16.7666C89.7044 17.0921 89.7598 17.4469 89.7598 17.8311V17.9922C89.7598 18.3763 89.7044 18.7311 89.5938 19.0566C89.4831 19.3789 89.3236 19.6589 89.1152 19.8965C88.9102 20.1341 88.6628 20.3197 88.373 20.4531C88.0833 20.5833 87.7611 20.6484 87.4062 20.6484C87.0482 20.6484 86.7243 20.5833 86.4346 20.4531C86.1449 20.3197 85.8958 20.1341 85.6875 19.8965C85.4792 19.6589 85.3197 19.3789 85.209 19.0566C85.0983 18.7311 85.043 18.3763 85.043 17.9922ZM85.624 17.8311V17.9922C85.624 18.2819 85.6631 18.557 85.7412 18.8174C85.8193 19.0745 85.9333 19.304 86.083 19.5059C86.2327 19.7044 86.4183 19.8607 86.6396 19.9746C86.861 20.0885 87.1165 20.1455 87.4062 20.1455C87.6927 20.1455 87.945 20.0885 88.1631 19.9746C88.3844 19.8607 88.57 19.7044 88.7197 19.5059C88.8695 19.304 88.9818 19.0745 89.0566 18.8174C89.1348 18.557 89.1738 18.2819 89.1738 17.9922V17.8311C89.1738 17.5446 89.1348 17.2728 89.0566 17.0156C88.9818 16.7585 88.8678 16.529 88.7148 16.3271C88.5651 16.1253 88.3796 15.9658 88.1582 15.8486C87.9368 15.7314 87.6829 15.6729 87.3965 15.6729C87.11 15.6729 86.8561 15.7314 86.6348 15.8486C86.4167 15.9658 86.2311 16.1253 86.0781 16.3271C85.9284 16.529 85.8145 16.7585 85.7363 17.0156C85.6615 17.2728 85.624 17.5446 85.624 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M91.5518 16.3955V20.5508H90.9707V15.2676H91.5273L91.5518 16.3955ZM91.4199 17.582L91.1611 17.4355C91.1807 17.123 91.2441 16.8301 91.3516 16.5566C91.459 16.2832 91.6038 16.0423 91.7861 15.834C91.9717 15.6257 92.1882 15.4629 92.4355 15.3457C92.6862 15.2285 92.9629 15.1699 93.2656 15.1699C93.5293 15.1699 93.7653 15.2057 93.9736 15.2773C94.182 15.349 94.3594 15.4629 94.5059 15.6191C94.6523 15.7754 94.763 15.9756 94.8379 16.2197C94.916 16.4639 94.9551 16.7617 94.9551 17.1133V20.5508H94.3691V17.1084C94.3691 16.7438 94.3187 16.459 94.2178 16.2539C94.1169 16.0456 93.9736 15.8975 93.7881 15.8096C93.6025 15.7217 93.3828 15.6777 93.1289 15.6777C92.849 15.6777 92.6032 15.7396 92.3916 15.8633C92.1833 15.9837 92.0075 16.1416 91.8643 16.3369C91.7243 16.529 91.6169 16.7357 91.542 16.957C91.4671 17.1751 91.4264 17.3835 91.4199 17.582Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M63.2246 37.5205L65.7734 26.7539H67.1973L67.5225 28.5469L64.8066 39.5508H63.2773L63.2246 37.5205ZM61.915 26.7539L64.0244 37.5205L63.8486 39.5508H62.1436L59.3047 26.7539H61.915ZM69.7637 37.4766L71.8467 26.7539H74.457L71.627 39.5508H69.9219L69.7637 37.4766ZM67.9971 26.7539L70.5635 37.5645L70.4932 39.5508H68.9639L66.2305 28.5381L66.582 26.7539H67.9971Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M78.4033 30.041V39.5508H75.8633V30.041H78.4033ZM75.7051 27.5625C75.7051 27.1934 75.834 26.8887 76.0918 26.6484C76.3496 26.4082 76.6953 26.2881 77.1289 26.2881C77.5566 26.2881 77.8994 26.4082 78.1572 26.6484C78.4209 26.8887 78.5527 27.1934 78.5527 27.5625C78.5527 27.9316 78.4209 28.2363 78.1572 28.4766C77.8994 28.7168 77.5566 28.8369 77.1289 28.8369C76.6953 28.8369 76.3496 28.7168 76.0918 28.4766C75.834 28.2363 75.7051 27.9316 75.7051 27.5625Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M82.9736 32.0713V39.5508H80.4424V30.041H82.8154L82.9736 32.0713ZM82.6045 34.4619H81.9189C81.9189 33.7588 82.0098 33.126 82.1914 32.5635C82.373 31.9951 82.6279 31.5117 82.9561 31.1133C83.2842 30.709 83.6738 30.4014 84.125 30.1904C84.582 29.9736 85.0918 29.8652 85.6543 29.8652C86.0996 29.8652 86.5068 29.9297 86.876 30.0586C87.2451 30.1875 87.5615 30.3926 87.8252 30.6738C88.0947 30.9551 88.2998 31.3271 88.4404 31.79C88.5869 32.2529 88.6602 32.8184 88.6602 33.4863V39.5508H86.1113V33.4775C86.1113 33.0557 86.0527 32.7275 85.9355 32.4932C85.8184 32.2588 85.6455 32.0947 85.417 32.001C85.1943 31.9014 84.9189 31.8516 84.5908 31.8516C84.251 31.8516 83.9551 31.9189 83.7031 32.0537C83.457 32.1885 83.252 32.376 83.0879 32.6162C82.9297 32.8506 82.8096 33.126 82.7275 33.4424C82.6455 33.7588 82.6045 34.0986 82.6045 34.4619Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M96.2012 37.4766V26.0508H98.75V39.5508H96.4561L96.2012 37.4766ZM90.1895 34.9102V34.7256C90.1895 33.999 90.2715 33.3398 90.4355 32.748C90.5996 32.1504 90.8398 31.6377 91.1562 31.21C91.4727 30.7822 91.8623 30.4512 92.3252 30.2168C92.7881 29.9824 93.3154 29.8652 93.9072 29.8652C94.4639 29.8652 94.9502 29.9824 95.3662 30.2168C95.7881 30.4512 96.1455 30.7852 96.4385 31.2188C96.7373 31.6465 96.9775 32.1533 97.1592 32.7393C97.3408 33.3193 97.4727 33.9551 97.5547 34.6465V35.0508C97.4727 35.7129 97.3408 36.3281 97.1592 36.8965C96.9775 37.4648 96.7373 37.9629 96.4385 38.3906C96.1455 38.8125 95.7881 39.1406 95.3662 39.375C94.9443 39.6094 94.4521 39.7266 93.8896 39.7266C93.2979 39.7266 92.7705 39.6064 92.3076 39.3662C91.8506 39.126 91.4639 38.7891 91.1475 38.3555C90.8369 37.9219 90.5996 37.4121 90.4355 36.8262C90.2715 36.2402 90.1895 35.6016 90.1895 34.9102ZM92.7207 34.7256V34.9102C92.7207 35.3027 92.75 35.6689 92.8086 36.0088C92.873 36.3486 92.9756 36.6504 93.1162 36.9141C93.2627 37.1719 93.4502 37.374 93.6787 37.5205C93.9131 37.6611 94.1973 37.7314 94.5312 37.7314C94.9648 37.7314 95.3223 37.6348 95.6035 37.4414C95.8848 37.2422 96.0986 36.9697 96.2451 36.624C96.3975 36.2783 96.4854 35.8799 96.5088 35.4287V34.2773C96.4912 33.9082 96.4385 33.5771 96.3506 33.2842C96.2686 32.9854 96.1455 32.7305 95.9814 32.5195C95.8232 32.3086 95.624 32.1445 95.3838 32.0273C95.1494 31.9102 94.8711 31.8516 94.5488 31.8516C94.2207 31.8516 93.9395 31.9277 93.7051 32.0801C93.4707 32.2266 93.2803 32.4287 93.1338 32.6865C92.9932 32.9443 92.8877 33.249 92.8174 33.6006C92.7529 33.9463 92.7207 34.3213 92.7207 34.7256Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M100.323 34.8926V34.708C100.323 34.0107 100.423 33.3691 100.622 32.7832C100.821 32.1914 101.111 31.6787 101.492 31.2451C101.873 30.8115 102.342 30.4746 102.898 30.2344C103.455 29.9883 104.094 29.8652 104.814 29.8652C105.535 29.8652 106.177 29.9883 106.739 30.2344C107.302 30.4746 107.773 30.8115 108.154 31.2451C108.541 31.6787 108.834 32.1914 109.033 32.7832C109.232 33.3691 109.332 34.0107 109.332 34.708V34.8926C109.332 35.584 109.232 36.2256 109.033 36.8174C108.834 37.4033 108.541 37.916 108.154 38.3555C107.773 38.7891 107.305 39.126 106.748 39.3662C106.191 39.6064 105.553 39.7266 104.832 39.7266C104.111 39.7266 103.47 39.6064 102.907 39.3662C102.351 39.126 101.879 38.7891 101.492 38.3555C101.111 37.916 100.821 37.4033 100.622 36.8174C100.423 36.2256 100.323 35.584 100.323 34.8926ZM102.854 34.708V34.8926C102.854 35.291 102.89 35.6631 102.96 36.0088C103.03 36.3545 103.142 36.6592 103.294 36.9229C103.452 37.1807 103.657 37.3828 103.909 37.5293C104.161 37.6758 104.469 37.749 104.832 37.749C105.184 37.749 105.485 37.6758 105.737 37.5293C105.989 37.3828 106.191 37.1807 106.344 36.9229C106.496 36.6592 106.607 36.3545 106.678 36.0088C106.754 35.6631 106.792 35.291 106.792 34.8926V34.708C106.792 34.3213 106.754 33.958 106.678 33.6182C106.607 33.2725 106.493 32.9678 106.335 32.7041C106.183 32.4346 105.98 32.2236 105.729 32.0713C105.477 31.9189 105.172 31.8428 104.814 31.8428C104.457 31.8428 104.152 31.9189 103.9 32.0713C103.654 32.2236 103.452 32.4346 103.294 32.7041C103.142 32.9678 103.03 33.2725 102.96 33.6182C102.89 33.958 102.854 34.3213 102.854 34.708Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M113.604 37.0898L115.581 30.041H117.189L116.671 32.8096L114.693 39.5508H113.349L113.604 37.0898ZM112.602 30.041L114.017 37.0811L114.148 39.5508H112.566L110.158 30.041H112.602ZM119 36.9668L120.38 30.041H122.832L120.424 39.5508H118.851L119 36.9668ZM117.409 30.041L119.378 37.0371L119.65 39.5508H118.297L116.319 32.8184L115.818 30.041H117.409Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M129.248 36.9229C129.248 36.7412 129.195 36.5771 129.09 36.4307C128.984 36.2842 128.788 36.1494 128.501 36.0264C128.22 35.8975 127.812 35.7803 127.279 35.6748C126.799 35.5693 126.351 35.4375 125.935 35.2793C125.524 35.1152 125.167 34.9189 124.862 34.6904C124.563 34.4619 124.329 34.1924 124.159 33.8818C123.989 33.5654 123.904 33.2051 123.904 32.8008C123.904 32.4023 123.989 32.0273 124.159 31.6758C124.335 31.3242 124.584 31.0137 124.906 30.7441C125.234 30.4688 125.633 30.2549 126.102 30.1025C126.576 29.9443 127.109 29.8652 127.701 29.8652C128.527 29.8652 129.236 29.9971 129.828 30.2607C130.426 30.5244 130.883 30.8877 131.199 31.3506C131.521 31.8076 131.683 32.3291 131.683 32.915H129.151C129.151 32.6689 129.099 32.4492 128.993 32.2559C128.894 32.0566 128.735 31.9014 128.519 31.79C128.308 31.6729 128.032 31.6143 127.692 31.6143C127.411 31.6143 127.168 31.6641 126.963 31.7637C126.758 31.8574 126.6 31.9863 126.488 32.1504C126.383 32.3086 126.33 32.4844 126.33 32.6777C126.33 32.8242 126.359 32.9561 126.418 33.0732C126.482 33.1846 126.585 33.2871 126.726 33.3809C126.866 33.4746 127.048 33.5625 127.271 33.6445C127.499 33.7207 127.78 33.791 128.114 33.8555C128.8 33.9961 129.412 34.1807 129.951 34.4092C130.49 34.6318 130.918 34.9365 131.234 35.3232C131.551 35.7041 131.709 36.2051 131.709 36.8262C131.709 37.248 131.615 37.6348 131.428 37.9863C131.24 38.3379 130.971 38.6455 130.619 38.9092C130.268 39.167 129.846 39.3691 129.354 39.5156C128.867 39.6562 128.319 39.7266 127.71 39.7266C126.825 39.7266 126.075 39.5684 125.46 39.252C124.851 38.9355 124.388 38.5342 124.071 38.0479C123.761 37.5557 123.605 37.0518 123.605 36.5361H126.005C126.017 36.8818 126.104 37.1602 126.269 37.3711C126.438 37.582 126.652 37.7344 126.91 37.8281C127.174 37.9219 127.458 37.9688 127.763 37.9688C128.091 37.9688 128.363 37.9248 128.58 37.8369C128.797 37.7432 128.961 37.6201 129.072 37.4678C129.189 37.3096 129.248 37.1279 129.248 36.9229Z\"\n      fill=\"#0A0A0B\"\n    />\n  </svg>\n</template>\n\n<style scoped lang=\"scss\"></style>\n","<script setup lang=\"ts\"></script>\n\n<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"158\"\n    height=\"56\"\n    viewBox=\"0 0 158 56\"\n    fill=\"none\"\n  >\n    <path\n      d=\"M0.5 7.55078C0.5 3.96093 3.41015 1.05078 7 1.05078H151C154.59 1.05078 157.5 3.96093 157.5 7.55078V48.5508C157.5 52.1406 154.59 55.0508 151 55.0508H7C3.41015 55.0508 0.5 52.1406 0.5 48.5508V7.55078Z\"\n      stroke=\"#0A0A0B\"\n    />\n    <path\n      d=\"M58.8496 20.5508H57.2383L57.248 20.0381H58.8496C59.3607 20.0381 59.8001 19.9242 60.168 19.6963C60.5391 19.4652 60.8255 19.1462 61.0273 18.7393C61.2292 18.3324 61.3301 17.8604 61.3301 17.3232V16.6592C61.3301 16.249 61.2715 15.8779 61.1543 15.5459C61.0404 15.2139 60.876 14.9307 60.6611 14.6963C60.4463 14.4587 60.1891 14.2764 59.8896 14.1494C59.5934 14.0225 59.2614 13.959 58.8936 13.959H57.209V13.4414H58.8936C59.3363 13.4414 59.7415 13.5179 60.1094 13.6709C60.4805 13.8206 60.8011 14.0387 61.0713 14.3252C61.3447 14.6084 61.5547 14.9486 61.7012 15.3457C61.8509 15.7428 61.9258 16.1855 61.9258 16.6738V17.3232C61.9258 17.8115 61.8509 18.2542 61.7012 18.6514C61.5547 19.0485 61.3447 19.3887 61.0713 19.6719C60.7979 19.9551 60.474 20.1732 60.0996 20.3262C59.7253 20.4759 59.3086 20.5508 58.8496 20.5508ZM57.5068 13.4414V20.5508H56.9062V13.4414H57.5068Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M63 17.9922V17.8311C63 17.4469 63.0553 17.0921 63.166 16.7666C63.2767 16.4411 63.4346 16.1595 63.6396 15.9219C63.848 15.6842 64.097 15.5003 64.3867 15.3701C64.6764 15.2367 64.9987 15.1699 65.3535 15.1699C65.7116 15.1699 66.0355 15.2367 66.3252 15.3701C66.6149 15.5003 66.8639 15.6842 67.0723 15.9219C67.2806 16.1595 67.4401 16.4411 67.5508 16.7666C67.6615 17.0921 67.7168 17.4469 67.7168 17.8311V17.9922C67.7168 18.3763 67.6615 18.7311 67.5508 19.0566C67.4401 19.3789 67.2806 19.6589 67.0723 19.8965C66.8672 20.1341 66.6198 20.3197 66.3301 20.4531C66.0404 20.5833 65.7181 20.6484 65.3633 20.6484C65.0052 20.6484 64.6813 20.5833 64.3916 20.4531C64.1019 20.3197 63.8529 20.1341 63.6445 19.8965C63.4362 19.6589 63.2767 19.3789 63.166 19.0566C63.0553 18.7311 63 18.3763 63 17.9922ZM63.5811 17.8311V17.9922C63.5811 18.2819 63.6201 18.557 63.6982 18.8174C63.7764 19.0745 63.8903 19.304 64.04 19.5059C64.1898 19.7044 64.3753 19.8607 64.5967 19.9746C64.818 20.0885 65.0736 20.1455 65.3633 20.1455C65.6497 20.1455 65.902 20.0885 66.1201 19.9746C66.3415 19.8607 66.527 19.7044 66.6768 19.5059C66.8265 19.304 66.9388 19.0745 67.0137 18.8174C67.0918 18.557 67.1309 18.2819 67.1309 17.9922V17.8311C67.1309 17.5446 67.0918 17.2728 67.0137 17.0156C66.9388 16.7585 66.8249 16.529 66.6719 16.3271C66.5221 16.1253 66.3366 15.9658 66.1152 15.8486C65.8939 15.7314 65.64 15.6729 65.3535 15.6729C65.0671 15.6729 64.8132 15.7314 64.5918 15.8486C64.3737 15.9658 64.1882 16.1253 64.0352 16.3271C63.8854 16.529 63.7715 16.7585 63.6934 17.0156C63.6185 17.2728 63.5811 17.5446 63.5811 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M70.3926 19.3154L71.667 15.2676H72.0771L71.833 16.3564L70.5 20.5508H70.0898L70.3926 19.3154ZM69.0693 15.2676L70.1875 19.3398L70.4268 20.5508H70.002L68.4688 15.2676H69.0693ZM73.6641 19.3252L74.7529 15.2676H75.3535L73.8203 20.5508H73.4004L73.6641 19.3252ZM72.1602 15.2676L73.415 19.2812L73.7324 20.5508H73.3223L71.96 16.3516L71.7305 15.2676H72.1602Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M77.0576 16.3955V20.5508H76.4766V15.2676H77.0332L77.0576 16.3955ZM76.9258 17.582L76.667 17.4355C76.6865 17.123 76.75 16.8301 76.8574 16.5566C76.9648 16.2832 77.1097 16.0423 77.292 15.834C77.4775 15.6257 77.694 15.4629 77.9414 15.3457C78.1921 15.2285 78.4688 15.1699 78.7715 15.1699C79.0352 15.1699 79.2712 15.2057 79.4795 15.2773C79.6878 15.349 79.8652 15.4629 80.0117 15.6191C80.1582 15.7754 80.2689 15.9756 80.3438 16.2197C80.4219 16.4639 80.4609 16.7617 80.4609 17.1133V20.5508H79.875V17.1084C79.875 16.7438 79.8245 16.459 79.7236 16.2539C79.6227 16.0456 79.4795 15.8975 79.2939 15.8096C79.1084 15.7217 78.8887 15.6777 78.6348 15.6777C78.3548 15.6777 78.109 15.7396 77.8975 15.8633C77.6891 15.9837 77.5133 16.1416 77.3701 16.3369C77.2301 16.529 77.1227 16.7357 77.0479 16.957C76.973 17.1751 76.9323 17.3835 76.9258 17.582Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path d=\"M82.624 13.0508V20.5508H82.043V13.0508H82.624Z\" fill=\"#0A0A0B\" />\n    <path\n      d=\"M83.8984 17.9922V17.8311C83.8984 17.4469 83.9538 17.0921 84.0645 16.7666C84.1751 16.4411 84.333 16.1595 84.5381 15.9219C84.7464 15.6842 84.9954 15.5003 85.2852 15.3701C85.5749 15.2367 85.8971 15.1699 86.252 15.1699C86.61 15.1699 86.9339 15.2367 87.2236 15.3701C87.5133 15.5003 87.7624 15.6842 87.9707 15.9219C88.179 16.1595 88.3385 16.4411 88.4492 16.7666C88.5599 17.0921 88.6152 17.4469 88.6152 17.8311V17.9922C88.6152 18.3763 88.5599 18.7311 88.4492 19.0566C88.3385 19.3789 88.179 19.6589 87.9707 19.8965C87.7656 20.1341 87.5182 20.3197 87.2285 20.4531C86.9388 20.5833 86.6165 20.6484 86.2617 20.6484C85.9036 20.6484 85.5798 20.5833 85.29 20.4531C85.0003 20.3197 84.7513 20.1341 84.543 19.8965C84.3346 19.6589 84.1751 19.3789 84.0645 19.0566C83.9538 18.7311 83.8984 18.3763 83.8984 17.9922ZM84.4795 17.8311V17.9922C84.4795 18.2819 84.5186 18.557 84.5967 18.8174C84.6748 19.0745 84.7887 19.304 84.9385 19.5059C85.0882 19.7044 85.2738 19.8607 85.4951 19.9746C85.7165 20.0885 85.972 20.1455 86.2617 20.1455C86.5482 20.1455 86.8005 20.0885 87.0186 19.9746C87.2399 19.8607 87.4255 19.7044 87.5752 19.5059C87.7249 19.304 87.8372 19.0745 87.9121 18.8174C87.9902 18.557 88.0293 18.2819 88.0293 17.9922V17.8311C88.0293 17.5446 87.9902 17.2728 87.9121 17.0156C87.8372 16.7585 87.7233 16.529 87.5703 16.3271C87.4206 16.1253 87.235 15.9658 87.0137 15.8486C86.7923 15.7314 86.5384 15.6729 86.252 15.6729C85.9655 15.6729 85.7116 15.7314 85.4902 15.8486C85.2721 15.9658 85.0866 16.1253 84.9336 16.3271C84.7839 16.529 84.6699 16.7585 84.5918 17.0156C84.5169 17.2728 84.4795 17.5446 84.4795 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M93.0391 19.6035V16.8789C93.0391 16.6283 92.987 16.4118 92.8828 16.2295C92.7786 16.0472 92.6257 15.9072 92.4238 15.8096C92.222 15.7119 91.973 15.6631 91.6768 15.6631C91.4033 15.6631 91.1592 15.7119 90.9443 15.8096C90.7327 15.904 90.5651 16.0326 90.4414 16.1953C90.321 16.3548 90.2607 16.5322 90.2607 16.7275L89.6748 16.7227C89.6748 16.5241 89.7236 16.332 89.8213 16.1465C89.9189 15.9609 90.0573 15.7949 90.2363 15.6484C90.4154 15.502 90.6286 15.3864 90.876 15.3018C91.1266 15.2139 91.4017 15.1699 91.7012 15.1699C92.0788 15.1699 92.4108 15.2334 92.6973 15.3604C92.987 15.4873 93.2132 15.6777 93.376 15.9316C93.5387 16.1855 93.6201 16.5046 93.6201 16.8887V19.4424C93.6201 19.6247 93.6331 19.8135 93.6592 20.0088C93.6885 20.2041 93.7292 20.3652 93.7812 20.4922V20.5508H93.1611C93.1221 20.4336 93.0911 20.2871 93.0684 20.1113C93.0488 19.9323 93.0391 19.763 93.0391 19.6035ZM93.1758 17.4746L93.1855 17.9238H92.0381C91.7386 17.9238 91.4701 17.9515 91.2324 18.0068C90.998 18.0589 90.7995 18.137 90.6367 18.2412C90.474 18.3421 90.3486 18.4642 90.2607 18.6074C90.1761 18.7507 90.1338 18.9134 90.1338 19.0957C90.1338 19.2845 90.181 19.457 90.2754 19.6133C90.373 19.7695 90.5098 19.8949 90.6855 19.9893C90.8646 20.0804 91.0762 20.126 91.3203 20.126C91.6458 20.126 91.9323 20.0658 92.1797 19.9453C92.4303 19.8249 92.637 19.667 92.7998 19.4717C92.9626 19.2764 93.0716 19.0632 93.127 18.832L93.3809 19.1689C93.3385 19.3317 93.2604 19.4993 93.1465 19.6719C93.0358 19.8411 92.8909 20.0007 92.7119 20.1504C92.5329 20.2969 92.3213 20.4173 92.0771 20.5117C91.8363 20.6029 91.5628 20.6484 91.2568 20.6484C90.9118 20.6484 90.6107 20.5833 90.3535 20.4531C90.0996 20.3229 89.901 20.1455 89.7578 19.9209C89.6178 19.693 89.5479 19.4359 89.5479 19.1494C89.5479 18.889 89.6032 18.6562 89.7139 18.4512C89.8245 18.2428 89.9841 18.0671 90.1924 17.9238C90.404 17.7773 90.6579 17.6667 90.9541 17.5918C91.2536 17.5137 91.5889 17.4746 91.96 17.4746H93.1758Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M98.6201 19.5254V13.0508H99.2061V20.5508H98.6592L98.6201 19.5254ZM94.9531 17.9629V17.8604C94.9531 17.4502 95.0003 17.0807 95.0947 16.752C95.1891 16.4199 95.3242 16.1367 95.5 15.9023C95.679 15.6647 95.8939 15.484 96.1445 15.3604C96.3952 15.2334 96.6784 15.1699 96.9941 15.1699C97.3034 15.1699 97.5768 15.2204 97.8145 15.3213C98.0521 15.4222 98.2555 15.5671 98.4248 15.7559C98.5973 15.9447 98.7357 16.1693 98.8398 16.4297C98.9473 16.6901 99.0254 16.9798 99.0742 17.2988V18.6025C99.0352 18.902 98.9635 19.1771 98.8594 19.4277C98.7552 19.6751 98.6169 19.8916 98.4443 20.0771C98.2718 20.2594 98.0635 20.401 97.8193 20.502C97.5784 20.5996 97.3001 20.6484 96.9844 20.6484C96.6719 20.6484 96.3903 20.5833 96.1396 20.4531C95.889 20.3229 95.6758 20.139 95.5 19.9014C95.3242 19.6605 95.1891 19.3757 95.0947 19.0469C95.0003 18.7181 94.9531 18.3568 94.9531 17.9629ZM95.5391 17.8604V17.9629C95.5391 18.2721 95.57 18.5586 95.6318 18.8223C95.6937 19.0859 95.7881 19.3154 95.915 19.5107C96.042 19.7061 96.2031 19.859 96.3984 19.9697C96.5938 20.0804 96.8249 20.1357 97.0918 20.1357C97.4271 20.1357 97.7087 20.0723 97.9365 19.9453C98.1644 19.8151 98.3467 19.6442 98.4834 19.4326C98.6201 19.2178 98.7194 18.9834 98.7812 18.7295V17.2109C98.7422 17.0384 98.6852 16.8626 98.6104 16.6836C98.5355 16.5046 98.4329 16.3402 98.3027 16.1904C98.1758 16.0374 98.013 15.9154 97.8145 15.8242C97.6191 15.7298 97.3815 15.6826 97.1016 15.6826C96.8314 15.6826 96.5986 15.738 96.4033 15.8486C96.208 15.9593 96.0452 16.1139 95.915 16.3125C95.7881 16.5078 95.6937 16.7373 95.6318 17.001C95.57 17.2646 95.5391 17.5511 95.5391 17.8604Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M59.5166 32.0098V39.5508H56.9766V30.041H59.3584L59.5166 32.0098ZM59.165 34.4619H58.4619C58.4619 33.7998 58.541 33.1904 58.6992 32.6338C58.8633 32.0713 59.1006 31.585 59.4111 31.1748C59.7275 30.7588 60.1172 30.4365 60.5801 30.208C61.043 29.9795 61.5791 29.8652 62.1885 29.8652C62.6104 29.8652 62.9971 29.9297 63.3486 30.0586C63.7002 30.1816 64.002 30.3779 64.2539 30.6475C64.5117 30.9111 64.7109 31.2568 64.8516 31.6846C64.9922 32.1064 65.0625 32.6133 65.0625 33.2051V39.5508H62.5312V33.4863C62.5312 33.0527 62.4727 32.7188 62.3555 32.4844C62.2383 32.25 62.0713 32.0859 61.8545 31.9922C61.6436 31.8984 61.3887 31.8516 61.0898 31.8516C60.7617 31.8516 60.4746 31.9189 60.2285 32.0537C59.9883 32.1885 59.7891 32.376 59.6309 32.6162C59.4727 32.8506 59.3555 33.126 59.2793 33.4424C59.2031 33.7588 59.165 34.0986 59.165 34.4619ZM64.8252 34.1719L63.9199 34.2861C63.9199 33.665 63.9961 33.0879 64.1484 32.5547C64.3066 32.0215 64.5381 31.5527 64.8428 31.1484C65.1533 30.7441 65.5371 30.4307 65.9941 30.208C66.4512 29.9795 66.9785 29.8652 67.5762 29.8652C68.0332 29.8652 68.4492 29.9326 68.8242 30.0674C69.1992 30.1963 69.5186 30.4043 69.7822 30.6914C70.0518 30.9727 70.2568 31.3418 70.3975 31.7988C70.5439 32.2559 70.6172 32.8154 70.6172 33.4775V39.5508H68.0771V33.4775C68.0771 33.0381 68.0186 32.7041 67.9014 32.4756C67.79 32.2412 67.626 32.0801 67.4092 31.9922C67.1982 31.8984 66.9463 31.8516 66.6533 31.8516C66.3486 31.8516 66.082 31.9131 65.8535 32.0361C65.625 32.1533 65.4346 32.3174 65.2822 32.5283C65.1299 32.7393 65.0156 32.9854 64.9395 33.2666C64.8633 33.542 64.8252 33.8438 64.8252 34.1719Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M77.71 37.4062V33.1699C77.71 32.8652 77.6602 32.6045 77.5605 32.3877C77.4609 32.165 77.3057 31.9922 77.0947 31.8691C76.8896 31.7461 76.623 31.6846 76.2949 31.6846C76.0137 31.6846 75.7705 31.7344 75.5654 31.834C75.3604 31.9277 75.2021 32.0654 75.0908 32.2471C74.9795 32.4229 74.9238 32.6309 74.9238 32.8711H72.3926C72.3926 32.4668 72.4863 32.083 72.6738 31.7197C72.8613 31.3564 73.1338 31.0371 73.4912 30.7617C73.8486 30.4805 74.2734 30.2607 74.7656 30.1025C75.2637 29.9443 75.8203 29.8652 76.4355 29.8652C77.1738 29.8652 77.8301 29.9883 78.4043 30.2344C78.9785 30.4805 79.4297 30.8496 79.7578 31.3418C80.0918 31.834 80.2588 32.4492 80.2588 33.1875V37.2568C80.2588 37.7783 80.291 38.2061 80.3555 38.54C80.4199 38.8682 80.5137 39.1553 80.6367 39.4014V39.5508H78.0791C77.9561 39.293 77.8623 38.9707 77.7979 38.584C77.7393 38.1914 77.71 37.7988 77.71 37.4062ZM78.0439 33.7588L78.0615 35.1914H76.6465C76.3125 35.1914 76.0225 35.2295 75.7764 35.3057C75.5303 35.3818 75.3281 35.4902 75.1699 35.6309C75.0117 35.7656 74.8945 35.9238 74.8184 36.1055C74.748 36.2871 74.7129 36.4863 74.7129 36.7031C74.7129 36.9199 74.7627 37.1162 74.8623 37.292C74.9619 37.4619 75.1055 37.5967 75.293 37.6963C75.4805 37.79 75.7002 37.8369 75.9521 37.8369C76.333 37.8369 76.6641 37.7607 76.9453 37.6084C77.2266 37.4561 77.4434 37.2686 77.5957 37.0459C77.7539 36.8232 77.8359 36.6123 77.8418 36.4131L78.5098 37.4854C78.416 37.7256 78.2871 37.9746 78.123 38.2324C77.9648 38.4902 77.7627 38.7334 77.5166 38.9619C77.2705 39.1846 76.9746 39.3691 76.6289 39.5156C76.2832 39.6562 75.873 39.7266 75.3984 39.7266C74.7949 39.7266 74.2471 39.6064 73.7549 39.3662C73.2686 39.1201 72.8818 38.7832 72.5947 38.3555C72.3135 37.9219 72.1729 37.4297 72.1729 36.8789C72.1729 36.3809 72.2666 35.9385 72.4541 35.5518C72.6416 35.165 72.917 34.8398 73.2803 34.5762C73.6494 34.3066 74.1094 34.1045 74.6602 33.9697C75.2109 33.8291 75.8496 33.7588 76.5762 33.7588H78.0439Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M86.1387 37.749C86.4492 37.749 86.7246 37.6904 86.9648 37.5732C87.2051 37.4502 87.3926 37.2803 87.5273 37.0635C87.668 36.8408 87.7412 36.5801 87.7471 36.2812H90.1289C90.123 36.9492 89.9443 37.5439 89.5928 38.0654C89.2412 38.5811 88.7695 38.9883 88.1777 39.2871C87.5859 39.5801 86.9238 39.7266 86.1914 39.7266C85.4531 39.7266 84.8086 39.6035 84.2578 39.3574C83.7129 39.1113 83.2588 38.7715 82.8955 38.3379C82.5322 37.8984 82.2598 37.3887 82.0781 36.8086C81.8965 36.2227 81.8057 35.5957 81.8057 34.9277V34.6729C81.8057 33.999 81.8965 33.3721 82.0781 32.792C82.2598 32.2061 82.5322 31.6963 82.8955 31.2627C83.2588 30.8232 83.7129 30.4805 84.2578 30.2344C84.8027 29.9883 85.4414 29.8652 86.1738 29.8652C86.9531 29.8652 87.6357 30.0146 88.2217 30.3135C88.8135 30.6123 89.2764 31.04 89.6104 31.5967C89.9502 32.1475 90.123 32.8008 90.1289 33.5566H87.7471C87.7412 33.2402 87.6738 32.9531 87.5449 32.6953C87.4219 32.4375 87.2402 32.2324 87 32.0801C86.7656 31.9219 86.4756 31.8428 86.1299 31.8428C85.7607 31.8428 85.459 31.9219 85.2246 32.0801C84.9902 32.2324 84.8086 32.4434 84.6797 32.7129C84.5508 32.9766 84.46 33.2783 84.4072 33.6182C84.3604 33.9521 84.3369 34.3037 84.3369 34.6729V34.9277C84.3369 35.2969 84.3604 35.6514 84.4072 35.9912C84.4541 36.3311 84.542 36.6328 84.6709 36.8965C84.8057 37.1602 84.9902 37.3682 85.2246 37.5205C85.459 37.6729 85.7637 37.749 86.1387 37.749Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M102.267 32.8535V33.46C102.267 34.4326 102.135 35.3057 101.871 36.0791C101.607 36.8525 101.235 37.5117 100.755 38.0566C100.274 38.5957 99.7002 39.0088 99.0322 39.2959C98.3701 39.583 97.6348 39.7266 96.8262 39.7266C96.0234 39.7266 95.2881 39.583 94.6201 39.2959C93.958 39.0088 93.3838 38.5957 92.8975 38.0566C92.4111 37.5117 92.0332 36.8525 91.7637 36.0791C91.5 35.3057 91.3682 34.4326 91.3682 33.46V32.8535C91.3682 31.875 91.5 31.002 91.7637 30.2344C92.0273 29.4609 92.3994 28.8018 92.8799 28.2568C93.3662 27.7119 93.9404 27.2959 94.6025 27.0088C95.2705 26.7217 96.0059 26.5781 96.8086 26.5781C97.6172 26.5781 98.3525 26.7217 99.0146 27.0088C99.6826 27.2959 100.257 27.7119 100.737 28.2568C101.224 28.8018 101.599 29.4609 101.862 30.2344C102.132 31.002 102.267 31.875 102.267 32.8535ZM99.6035 33.46V32.8359C99.6035 32.1562 99.542 31.5586 99.4189 31.043C99.2959 30.5273 99.1143 30.0938 98.874 29.7422C98.6338 29.3906 98.3408 29.127 97.9951 28.9512C97.6494 28.7695 97.2539 28.6787 96.8086 28.6787C96.3633 28.6787 95.9678 28.7695 95.6221 28.9512C95.2822 29.127 94.9922 29.3906 94.752 29.7422C94.5176 30.0938 94.3389 30.5273 94.2158 31.043C94.0928 31.5586 94.0312 32.1562 94.0312 32.8359V33.46C94.0312 34.1338 94.0928 34.7314 94.2158 35.2529C94.3389 35.7686 94.5205 36.2051 94.7607 36.5625C95.001 36.9141 95.2939 37.1807 95.6396 37.3623C95.9854 37.5439 96.3809 37.6348 96.8262 37.6348C97.2715 37.6348 97.667 37.5439 98.0127 37.3623C98.3584 37.1807 98.6484 36.9141 98.8828 36.5625C99.1172 36.2051 99.2959 35.7686 99.4189 35.2529C99.542 34.7314 99.6035 34.1338 99.6035 33.46Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M110.827 36.2021C110.827 35.9736 110.792 35.7686 110.722 35.5869C110.657 35.3994 110.534 35.2295 110.353 35.0771C110.171 34.9189 109.916 34.7637 109.588 34.6113C109.26 34.459 108.835 34.3008 108.313 34.1367C107.733 33.9492 107.183 33.7383 106.661 33.5039C106.146 33.2695 105.688 32.9971 105.29 32.6865C104.897 32.3701 104.587 32.0039 104.358 31.5879C104.136 31.1719 104.024 30.6885 104.024 30.1377C104.024 29.6045 104.142 29.1211 104.376 28.6875C104.61 28.248 104.938 27.873 105.36 27.5625C105.782 27.2461 106.28 27.0029 106.854 26.833C107.435 26.6631 108.07 26.5781 108.762 26.5781C109.705 26.5781 110.528 26.748 111.231 27.0879C111.935 27.4277 112.479 27.8936 112.866 28.4854C113.259 29.0771 113.455 29.7539 113.455 30.5156H110.836C110.836 30.1406 110.757 29.8125 110.599 29.5312C110.446 29.2441 110.212 29.0186 109.896 28.8545C109.585 28.6904 109.192 28.6084 108.718 28.6084C108.261 28.6084 107.88 28.6787 107.575 28.8193C107.271 28.9541 107.042 29.1387 106.89 29.373C106.737 29.6016 106.661 29.8594 106.661 30.1465C106.661 30.3633 106.714 30.5596 106.819 30.7354C106.931 30.9111 107.095 31.0752 107.312 31.2275C107.528 31.3799 107.795 31.5234 108.111 31.6582C108.428 31.793 108.794 31.9248 109.21 32.0537C109.907 32.2646 110.52 32.502 111.047 32.7656C111.58 33.0293 112.025 33.3252 112.383 33.6533C112.74 33.9814 113.01 34.3535 113.191 34.7695C113.373 35.1855 113.464 35.6572 113.464 36.1846C113.464 36.7412 113.355 37.2393 113.139 37.6787C112.922 38.1182 112.608 38.4902 112.198 38.7949C111.788 39.0996 111.299 39.3311 110.73 39.4893C110.162 39.6475 109.526 39.7266 108.823 39.7266C108.19 39.7266 107.566 39.6445 106.951 39.4805C106.336 39.3105 105.776 39.0557 105.272 38.7158C104.774 38.376 104.376 37.9424 104.077 37.415C103.778 36.8877 103.629 36.2637 103.629 35.543H106.274C106.274 35.9414 106.336 36.2783 106.459 36.5537C106.582 36.8291 106.755 37.0518 106.978 37.2217C107.206 37.3916 107.476 37.5146 107.786 37.5908C108.103 37.667 108.448 37.7051 108.823 37.7051C109.28 37.7051 109.655 37.6406 109.948 37.5117C110.247 37.3828 110.467 37.2041 110.607 36.9756C110.754 36.7471 110.827 36.4893 110.827 36.2021Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M45.4783 28.0826C45.5269 33.0767 50.0756 34.7385 50.1259 34.7597C50.0873 34.8769 49.3991 37.128 47.7295 39.4532C46.2863 41.4635 44.7882 43.4664 42.4284 43.5079C40.11 43.5486 39.3643 42.1976 36.7134 42.1976C34.0633 42.1976 33.2349 43.4664 31.0401 43.5486C28.7623 43.6308 27.0278 41.3748 25.5726 39.3719C22.5988 35.2749 20.3263 27.7946 23.3777 22.7453C24.8936 20.2377 27.6028 18.65 30.5431 18.6092C32.7797 18.5686 34.8909 20.0432 36.2582 20.0432C37.6246 20.0432 40.1902 18.2699 42.8872 18.5303C44.0161 18.5751 47.1856 18.9648 49.2206 21.8036C49.0565 21.9005 45.4389 23.9074 45.4783 28.0826ZM41.1207 15.8198C42.3301 14.4248 43.1439 12.483 42.9219 10.5508C41.1788 10.6175 39.0711 11.6577 37.8208 13.0518C36.7003 14.2865 35.7191 16.2625 35.9839 18.1564C37.9267 18.2997 39.9114 17.2155 41.1207 15.8198Z\"\n      fill=\"#0A0A0B\"\n    />\n  </svg>\n</template>\n\n<style scoped lang=\"scss\"></style>\n","<script setup lang=\"ts\"></script>\n\n<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"158\"\n    height=\"56\"\n    viewBox=\"0 0 158 56\"\n    fill=\"none\"\n  >\n    <path\n      d=\"M0.5 7.55078C0.5 3.96093 3.41015 1.05078 7 1.05078H151C154.59 1.05078 157.5 3.96093 157.5 7.55078V48.5508C157.5 52.1406 154.59 55.0508 151 55.0508H7C3.41015 55.0508 0.5 52.1406 0.5 48.5508V7.55078Z\"\n      stroke=\"#0A0A0B\"\n    />\n    <path\n      d=\"M58.8496 20.5508H57.2383L57.248 20.0381H58.8496C59.3607 20.0381 59.8001 19.9242 60.168 19.6963C60.5391 19.4652 60.8255 19.1462 61.0273 18.7393C61.2292 18.3324 61.3301 17.8604 61.3301 17.3232V16.6592C61.3301 16.249 61.2715 15.8779 61.1543 15.5459C61.0404 15.2139 60.876 14.9307 60.6611 14.6963C60.4463 14.4587 60.1891 14.2764 59.8896 14.1494C59.5934 14.0225 59.2614 13.959 58.8936 13.959H57.209V13.4414H58.8936C59.3363 13.4414 59.7415 13.5179 60.1094 13.6709C60.4805 13.8206 60.8011 14.0387 61.0713 14.3252C61.3447 14.6084 61.5547 14.9486 61.7012 15.3457C61.8509 15.7428 61.9258 16.1855 61.9258 16.6738V17.3232C61.9258 17.8115 61.8509 18.2542 61.7012 18.6514C61.5547 19.0485 61.3447 19.3887 61.0713 19.6719C60.7979 19.9551 60.474 20.1732 60.0996 20.3262C59.7253 20.4759 59.3086 20.5508 58.8496 20.5508ZM57.5068 13.4414V20.5508H56.9062V13.4414H57.5068Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M63 17.9922V17.8311C63 17.4469 63.0553 17.0921 63.166 16.7666C63.2767 16.4411 63.4346 16.1595 63.6396 15.9219C63.848 15.6842 64.097 15.5003 64.3867 15.3701C64.6764 15.2367 64.9987 15.1699 65.3535 15.1699C65.7116 15.1699 66.0355 15.2367 66.3252 15.3701C66.6149 15.5003 66.8639 15.6842 67.0723 15.9219C67.2806 16.1595 67.4401 16.4411 67.5508 16.7666C67.6615 17.0921 67.7168 17.4469 67.7168 17.8311V17.9922C67.7168 18.3763 67.6615 18.7311 67.5508 19.0566C67.4401 19.3789 67.2806 19.6589 67.0723 19.8965C66.8672 20.1341 66.6198 20.3197 66.3301 20.4531C66.0404 20.5833 65.7181 20.6484 65.3633 20.6484C65.0052 20.6484 64.6813 20.5833 64.3916 20.4531C64.1019 20.3197 63.8529 20.1341 63.6445 19.8965C63.4362 19.6589 63.2767 19.3789 63.166 19.0566C63.0553 18.7311 63 18.3763 63 17.9922ZM63.5811 17.8311V17.9922C63.5811 18.2819 63.6201 18.557 63.6982 18.8174C63.7764 19.0745 63.8903 19.304 64.04 19.5059C64.1898 19.7044 64.3753 19.8607 64.5967 19.9746C64.818 20.0885 65.0736 20.1455 65.3633 20.1455C65.6497 20.1455 65.902 20.0885 66.1201 19.9746C66.3415 19.8607 66.527 19.7044 66.6768 19.5059C66.8265 19.304 66.9388 19.0745 67.0137 18.8174C67.0918 18.557 67.1309 18.2819 67.1309 17.9922V17.8311C67.1309 17.5446 67.0918 17.2728 67.0137 17.0156C66.9388 16.7585 66.8249 16.529 66.6719 16.3271C66.5221 16.1253 66.3366 15.9658 66.1152 15.8486C65.8939 15.7314 65.64 15.6729 65.3535 15.6729C65.0671 15.6729 64.8132 15.7314 64.5918 15.8486C64.3737 15.9658 64.1882 16.1253 64.0352 16.3271C63.8854 16.529 63.7715 16.7585 63.6934 17.0156C63.6185 17.2728 63.5811 17.5446 63.5811 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M70.3926 19.3154L71.667 15.2676H72.0771L71.833 16.3564L70.5 20.5508H70.0898L70.3926 19.3154ZM69.0693 15.2676L70.1875 19.3398L70.4268 20.5508H70.002L68.4688 15.2676H69.0693ZM73.6641 19.3252L74.7529 15.2676H75.3535L73.8203 20.5508H73.4004L73.6641 19.3252ZM72.1602 15.2676L73.415 19.2812L73.7324 20.5508H73.3223L71.96 16.3516L71.7305 15.2676H72.1602Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M77.0576 16.3955V20.5508H76.4766V15.2676H77.0332L77.0576 16.3955ZM76.9258 17.582L76.667 17.4355C76.6865 17.123 76.75 16.8301 76.8574 16.5566C76.9648 16.2832 77.1097 16.0423 77.292 15.834C77.4775 15.6257 77.694 15.4629 77.9414 15.3457C78.1921 15.2285 78.4688 15.1699 78.7715 15.1699C79.0352 15.1699 79.2712 15.2057 79.4795 15.2773C79.6878 15.349 79.8652 15.4629 80.0117 15.6191C80.1582 15.7754 80.2689 15.9756 80.3438 16.2197C80.4219 16.4639 80.4609 16.7617 80.4609 17.1133V20.5508H79.875V17.1084C79.875 16.7438 79.8245 16.459 79.7236 16.2539C79.6227 16.0456 79.4795 15.8975 79.2939 15.8096C79.1084 15.7217 78.8887 15.6777 78.6348 15.6777C78.3548 15.6777 78.109 15.7396 77.8975 15.8633C77.6891 15.9837 77.5133 16.1416 77.3701 16.3369C77.2301 16.529 77.1227 16.7357 77.0479 16.957C76.973 17.1751 76.9323 17.3835 76.9258 17.582Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path d=\"M82.624 13.0508V20.5508H82.043V13.0508H82.624Z\" fill=\"#0A0A0B\" />\n    <path\n      d=\"M83.8984 17.9922V17.8311C83.8984 17.4469 83.9538 17.0921 84.0645 16.7666C84.1751 16.4411 84.333 16.1595 84.5381 15.9219C84.7464 15.6842 84.9954 15.5003 85.2852 15.3701C85.5749 15.2367 85.8971 15.1699 86.252 15.1699C86.61 15.1699 86.9339 15.2367 87.2236 15.3701C87.5133 15.5003 87.7624 15.6842 87.9707 15.9219C88.179 16.1595 88.3385 16.4411 88.4492 16.7666C88.5599 17.0921 88.6152 17.4469 88.6152 17.8311V17.9922C88.6152 18.3763 88.5599 18.7311 88.4492 19.0566C88.3385 19.3789 88.179 19.6589 87.9707 19.8965C87.7656 20.1341 87.5182 20.3197 87.2285 20.4531C86.9388 20.5833 86.6165 20.6484 86.2617 20.6484C85.9036 20.6484 85.5798 20.5833 85.29 20.4531C85.0003 20.3197 84.7513 20.1341 84.543 19.8965C84.3346 19.6589 84.1751 19.3789 84.0645 19.0566C83.9538 18.7311 83.8984 18.3763 83.8984 17.9922ZM84.4795 17.8311V17.9922C84.4795 18.2819 84.5186 18.557 84.5967 18.8174C84.6748 19.0745 84.7887 19.304 84.9385 19.5059C85.0882 19.7044 85.2738 19.8607 85.4951 19.9746C85.7165 20.0885 85.972 20.1455 86.2617 20.1455C86.5482 20.1455 86.8005 20.0885 87.0186 19.9746C87.2399 19.8607 87.4255 19.7044 87.5752 19.5059C87.7249 19.304 87.8372 19.0745 87.9121 18.8174C87.9902 18.557 88.0293 18.2819 88.0293 17.9922V17.8311C88.0293 17.5446 87.9902 17.2728 87.9121 17.0156C87.8372 16.7585 87.7233 16.529 87.5703 16.3271C87.4206 16.1253 87.235 15.9658 87.0137 15.8486C86.7923 15.7314 86.5384 15.6729 86.252 15.6729C85.9655 15.6729 85.7116 15.7314 85.4902 15.8486C85.2721 15.9658 85.0866 16.1253 84.9336 16.3271C84.7839 16.529 84.6699 16.7585 84.5918 17.0156C84.5169 17.2728 84.4795 17.5446 84.4795 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M93.0391 19.6035V16.8789C93.0391 16.6283 92.987 16.4118 92.8828 16.2295C92.7786 16.0472 92.6257 15.9072 92.4238 15.8096C92.222 15.7119 91.973 15.6631 91.6768 15.6631C91.4033 15.6631 91.1592 15.7119 90.9443 15.8096C90.7327 15.904 90.5651 16.0326 90.4414 16.1953C90.321 16.3548 90.2607 16.5322 90.2607 16.7275L89.6748 16.7227C89.6748 16.5241 89.7236 16.332 89.8213 16.1465C89.9189 15.9609 90.0573 15.7949 90.2363 15.6484C90.4154 15.502 90.6286 15.3864 90.876 15.3018C91.1266 15.2139 91.4017 15.1699 91.7012 15.1699C92.0788 15.1699 92.4108 15.2334 92.6973 15.3604C92.987 15.4873 93.2132 15.6777 93.376 15.9316C93.5387 16.1855 93.6201 16.5046 93.6201 16.8887V19.4424C93.6201 19.6247 93.6331 19.8135 93.6592 20.0088C93.6885 20.2041 93.7292 20.3652 93.7812 20.4922V20.5508H93.1611C93.1221 20.4336 93.0911 20.2871 93.0684 20.1113C93.0488 19.9323 93.0391 19.763 93.0391 19.6035ZM93.1758 17.4746L93.1855 17.9238H92.0381C91.7386 17.9238 91.4701 17.9515 91.2324 18.0068C90.998 18.0589 90.7995 18.137 90.6367 18.2412C90.474 18.3421 90.3486 18.4642 90.2607 18.6074C90.1761 18.7507 90.1338 18.9134 90.1338 19.0957C90.1338 19.2845 90.181 19.457 90.2754 19.6133C90.373 19.7695 90.5098 19.8949 90.6855 19.9893C90.8646 20.0804 91.0762 20.126 91.3203 20.126C91.6458 20.126 91.9323 20.0658 92.1797 19.9453C92.4303 19.8249 92.637 19.667 92.7998 19.4717C92.9626 19.2764 93.0716 19.0632 93.127 18.832L93.3809 19.1689C93.3385 19.3317 93.2604 19.4993 93.1465 19.6719C93.0358 19.8411 92.8909 20.0007 92.7119 20.1504C92.5329 20.2969 92.3213 20.4173 92.0771 20.5117C91.8363 20.6029 91.5628 20.6484 91.2568 20.6484C90.9118 20.6484 90.6107 20.5833 90.3535 20.4531C90.0996 20.3229 89.901 20.1455 89.7578 19.9209C89.6178 19.693 89.5479 19.4359 89.5479 19.1494C89.5479 18.889 89.6032 18.6562 89.7139 18.4512C89.8245 18.2428 89.9841 18.0671 90.1924 17.9238C90.404 17.7773 90.6579 17.6667 90.9541 17.5918C91.2536 17.5137 91.5889 17.4746 91.96 17.4746H93.1758Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M98.6201 19.5254V13.0508H99.2061V20.5508H98.6592L98.6201 19.5254ZM94.9531 17.9629V17.8604C94.9531 17.4502 95.0003 17.0807 95.0947 16.752C95.1891 16.4199 95.3242 16.1367 95.5 15.9023C95.679 15.6647 95.8939 15.484 96.1445 15.3604C96.3952 15.2334 96.6784 15.1699 96.9941 15.1699C97.3034 15.1699 97.5768 15.2204 97.8145 15.3213C98.0521 15.4222 98.2555 15.5671 98.4248 15.7559C98.5973 15.9447 98.7357 16.1693 98.8398 16.4297C98.9473 16.6901 99.0254 16.9798 99.0742 17.2988V18.6025C99.0352 18.902 98.9635 19.1771 98.8594 19.4277C98.7552 19.6751 98.6169 19.8916 98.4443 20.0771C98.2718 20.2594 98.0635 20.401 97.8193 20.502C97.5784 20.5996 97.3001 20.6484 96.9844 20.6484C96.6719 20.6484 96.3903 20.5833 96.1396 20.4531C95.889 20.3229 95.6758 20.139 95.5 19.9014C95.3242 19.6605 95.1891 19.3757 95.0947 19.0469C95.0003 18.7181 94.9531 18.3568 94.9531 17.9629ZM95.5391 17.8604V17.9629C95.5391 18.2721 95.57 18.5586 95.6318 18.8223C95.6937 19.0859 95.7881 19.3154 95.915 19.5107C96.042 19.7061 96.2031 19.859 96.3984 19.9697C96.5938 20.0804 96.8249 20.1357 97.0918 20.1357C97.4271 20.1357 97.7087 20.0723 97.9365 19.9453C98.1644 19.8151 98.3467 19.6442 98.4834 19.4326C98.6201 19.2178 98.7194 18.9834 98.7812 18.7295V17.2109C98.7422 17.0384 98.6852 16.8626 98.6104 16.6836C98.5355 16.5046 98.4329 16.3402 98.3027 16.1904C98.1758 16.0374 98.013 15.9154 97.8145 15.8242C97.6191 15.7298 97.3815 15.6826 97.1016 15.6826C96.8314 15.6826 96.5986 15.738 96.4033 15.8486C96.208 15.9593 96.0452 16.1139 95.915 16.3125C95.7881 16.5078 95.6937 16.7373 95.6318 17.001C95.57 17.2646 95.5391 17.5511 95.5391 17.8604Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M102.863 17.9922V17.8311C102.863 17.4469 102.919 17.0921 103.029 16.7666C103.14 16.4411 103.298 16.1595 103.503 15.9219C103.711 15.6842 103.96 15.5003 104.25 15.3701C104.54 15.2367 104.862 15.1699 105.217 15.1699C105.575 15.1699 105.899 15.2367 106.188 15.3701C106.478 15.5003 106.727 15.6842 106.936 15.9219C107.144 16.1595 107.303 16.4411 107.414 16.7666C107.525 17.0921 107.58 17.4469 107.58 17.8311V17.9922C107.58 18.3763 107.525 18.7311 107.414 19.0566C107.303 19.3789 107.144 19.6589 106.936 19.8965C106.73 20.1341 106.483 20.3197 106.193 20.4531C105.904 20.5833 105.581 20.6484 105.227 20.6484C104.868 20.6484 104.545 20.5833 104.255 20.4531C103.965 20.3197 103.716 20.1341 103.508 19.8965C103.299 19.6589 103.14 19.3789 103.029 19.0566C102.919 18.7311 102.863 18.3763 102.863 17.9922ZM103.444 17.8311V17.9922C103.444 18.2819 103.483 18.557 103.562 18.8174C103.64 19.0745 103.754 19.304 103.903 19.5059C104.053 19.7044 104.239 19.8607 104.46 19.9746C104.681 20.0885 104.937 20.1455 105.227 20.1455C105.513 20.1455 105.765 20.0885 105.983 19.9746C106.205 19.8607 106.39 19.7044 106.54 19.5059C106.69 19.304 106.802 19.0745 106.877 18.8174C106.955 18.557 106.994 18.2819 106.994 17.9922V17.8311C106.994 17.5446 106.955 17.2728 106.877 17.0156C106.802 16.7585 106.688 16.529 106.535 16.3271C106.385 16.1253 106.2 15.9658 105.979 15.8486C105.757 15.7314 105.503 15.6729 105.217 15.6729C104.93 15.6729 104.676 15.7314 104.455 15.8486C104.237 15.9658 104.051 16.1253 103.898 16.3271C103.749 16.529 103.635 16.7585 103.557 17.0156C103.482 17.2728 103.444 17.5446 103.444 17.8311Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M109.372 16.3955V20.5508H108.791V15.2676H109.348L109.372 16.3955ZM109.24 17.582L108.981 17.4355C109.001 17.123 109.064 16.8301 109.172 16.5566C109.279 16.2832 109.424 16.0423 109.606 15.834C109.792 15.6257 110.008 15.4629 110.256 15.3457C110.507 15.2285 110.783 15.1699 111.086 15.1699C111.35 15.1699 111.586 15.2057 111.794 15.2773C112.002 15.349 112.18 15.4629 112.326 15.6191C112.473 15.7754 112.583 15.9756 112.658 16.2197C112.736 16.4639 112.775 16.7617 112.775 17.1133V20.5508H112.189V17.1084C112.189 16.7438 112.139 16.459 112.038 16.2539C111.937 16.0456 111.794 15.8975 111.608 15.8096C111.423 15.7217 111.203 15.6777 110.949 15.6777C110.669 15.6777 110.424 15.7396 110.212 15.8633C110.004 15.9837 109.828 16.1416 109.685 16.3369C109.545 16.529 109.437 16.7357 109.362 16.957C109.287 17.1751 109.247 17.3835 109.24 17.582Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M118.728 15.2676V15.7461H116.081V15.2676H118.728ZM117.053 13.9102H117.634V19.2666C117.634 19.5107 117.666 19.6947 117.731 19.8184C117.797 19.9421 117.881 20.0251 117.985 20.0674C118.09 20.1097 118.202 20.1309 118.322 20.1309C118.41 20.1309 118.495 20.126 118.576 20.1162C118.658 20.1032 118.731 20.0902 118.796 20.0771L118.82 20.5703C118.749 20.5931 118.656 20.611 118.542 20.624C118.428 20.6403 118.314 20.6484 118.2 20.6484C117.976 20.6484 117.777 20.6077 117.604 20.5264C117.432 20.4417 117.297 20.2985 117.199 20.0967C117.102 19.8916 117.053 19.6133 117.053 19.2617V13.9102Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M120.534 13.0508V20.5508H119.953V13.0508H120.534ZM120.402 17.582L120.144 17.4355C120.163 17.123 120.227 16.8301 120.334 16.5566C120.441 16.2832 120.586 16.0423 120.769 15.834C120.954 15.6257 121.171 15.4629 121.418 15.3457C121.669 15.2285 121.945 15.1699 122.248 15.1699C122.512 15.1699 122.748 15.2057 122.956 15.2773C123.164 15.349 123.342 15.4629 123.488 15.6191C123.635 15.7754 123.745 15.9756 123.82 16.2197C123.898 16.4639 123.938 16.7617 123.938 17.1133V20.5508H123.352V17.1084C123.352 16.7438 123.301 16.459 123.2 16.2539C123.099 16.0456 122.956 15.8975 122.771 15.8096C122.585 15.7217 122.365 15.6777 122.111 15.6777C121.831 15.6777 121.586 15.7396 121.374 15.8633C121.166 15.9837 120.99 16.1416 120.847 16.3369C120.707 16.529 120.599 16.7357 120.524 16.957C120.45 17.1751 120.409 17.3835 120.402 17.582Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M127.482 20.6484C127.137 20.6484 126.82 20.585 126.53 20.458C126.244 20.3311 125.993 20.152 125.778 19.9209C125.567 19.6898 125.402 19.4163 125.285 19.1006C125.171 18.7816 125.114 18.4333 125.114 18.0557V17.8457C125.114 17.4388 125.174 17.071 125.295 16.7422C125.415 16.4134 125.581 16.1318 125.793 15.8975C126.005 15.6631 126.245 15.484 126.516 15.3604C126.789 15.2334 127.076 15.1699 127.375 15.1699C127.71 15.1699 128.008 15.2301 128.269 15.3506C128.529 15.4678 128.747 15.6354 128.923 15.8535C129.102 16.0684 129.237 16.3239 129.328 16.6201C129.419 16.9131 129.465 17.237 129.465 17.5918V17.9482H125.466V17.4502H128.884V17.3818C128.877 17.0856 128.817 16.8089 128.703 16.5518C128.592 16.2913 128.426 16.0798 128.205 15.917C127.984 15.7542 127.707 15.6729 127.375 15.6729C127.128 15.6729 126.9 15.7249 126.691 15.8291C126.486 15.9333 126.309 16.083 126.159 16.2783C126.013 16.4704 125.899 16.6999 125.817 16.9668C125.739 17.2305 125.7 17.5234 125.7 17.8457V18.0557C125.7 18.3486 125.743 18.6221 125.827 18.876C125.915 19.1266 126.039 19.348 126.198 19.54C126.361 19.7321 126.553 19.8818 126.774 19.9893C126.996 20.0967 127.24 20.1504 127.507 20.1504C127.819 20.1504 128.096 20.0934 128.337 19.9795C128.578 19.8623 128.794 19.6784 128.986 19.4277L129.353 19.7109C129.239 19.8802 129.095 20.0365 128.923 20.1797C128.754 20.3229 128.55 20.4368 128.312 20.5215C128.075 20.6061 127.798 20.6484 127.482 20.6484Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M62.3467 28.9424L58.8662 39.5508H56.0625L60.8174 26.7539H62.6016L62.3467 28.9424ZM65.2383 39.5508L61.749 28.9424L61.4678 26.7539H63.2695L68.0508 39.5508H65.2383ZM65.0801 34.7871V36.8525H58.3213V34.7871H65.0801Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M71.3291 31.8691V43.207H68.7979V30.041H71.1445L71.3291 31.8691ZM77.3496 34.6904V34.875C77.3496 35.5664 77.2676 36.208 77.1035 36.7998C76.9453 37.3916 76.7109 37.9072 76.4004 38.3467C76.0898 38.7803 75.7031 39.1201 75.2402 39.3662C74.7832 39.6064 74.2559 39.7266 73.6582 39.7266C73.0781 39.7266 72.5742 39.6094 72.1465 39.375C71.7188 39.1406 71.3584 38.8125 71.0654 38.3906C70.7783 37.9629 70.5469 37.4678 70.3711 36.9053C70.1953 36.3428 70.0605 35.7393 69.9668 35.0947V34.6113C70.0605 33.9199 70.1953 33.2871 70.3711 32.7129C70.5469 32.1328 70.7783 31.6318 71.0654 31.21C71.3584 30.7822 71.7158 30.4512 72.1377 30.2168C72.5654 29.9824 73.0664 29.8652 73.6406 29.8652C74.2441 29.8652 74.7744 29.9795 75.2314 30.208C75.6943 30.4365 76.0811 30.7646 76.3916 31.1924C76.708 31.6201 76.9453 32.1299 77.1035 32.7217C77.2676 33.3135 77.3496 33.9697 77.3496 34.6904ZM74.8096 34.875V34.6904C74.8096 34.2861 74.7744 33.9141 74.7041 33.5742C74.6396 33.2285 74.5342 32.9268 74.3877 32.6689C74.2471 32.4111 74.0596 32.2119 73.8252 32.0713C73.5967 31.9248 73.3184 31.8516 72.9902 31.8516C72.6445 31.8516 72.3486 31.9072 72.1025 32.0186C71.8623 32.1299 71.666 32.291 71.5137 32.502C71.3613 32.7129 71.2471 32.9648 71.1709 33.2578C71.0947 33.5508 71.0479 33.8818 71.0303 34.251V35.4727C71.0596 35.9062 71.1416 36.2959 71.2764 36.6416C71.4111 36.9814 71.6191 37.251 71.9004 37.4502C72.1816 37.6494 72.5508 37.749 73.0078 37.749C73.3418 37.749 73.623 37.6758 73.8516 37.5293C74.0801 37.377 74.2646 37.1689 74.4053 36.9053C74.5518 36.6416 74.6543 36.3369 74.7129 35.9912C74.7773 35.6455 74.8096 35.2734 74.8096 34.875Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M81.4541 31.8691V43.207H78.9229V30.041H81.2695L81.4541 31.8691ZM87.4746 34.6904V34.875C87.4746 35.5664 87.3926 36.208 87.2285 36.7998C87.0703 37.3916 86.8359 37.9072 86.5254 38.3467C86.2148 38.7803 85.8281 39.1201 85.3652 39.3662C84.9082 39.6064 84.3809 39.7266 83.7832 39.7266C83.2031 39.7266 82.6992 39.6094 82.2715 39.375C81.8438 39.1406 81.4834 38.8125 81.1904 38.3906C80.9033 37.9629 80.6719 37.4678 80.4961 36.9053C80.3203 36.3428 80.1855 35.7393 80.0918 35.0947V34.6113C80.1855 33.9199 80.3203 33.2871 80.4961 32.7129C80.6719 32.1328 80.9033 31.6318 81.1904 31.21C81.4834 30.7822 81.8408 30.4512 82.2627 30.2168C82.6904 29.9824 83.1914 29.8652 83.7656 29.8652C84.3691 29.8652 84.8994 29.9795 85.3564 30.208C85.8193 30.4365 86.2061 30.7646 86.5166 31.1924C86.833 31.6201 87.0703 32.1299 87.2285 32.7217C87.3926 33.3135 87.4746 33.9697 87.4746 34.6904ZM84.9346 34.875V34.6904C84.9346 34.2861 84.8994 33.9141 84.8291 33.5742C84.7646 33.2285 84.6592 32.9268 84.5127 32.6689C84.3721 32.4111 84.1846 32.2119 83.9502 32.0713C83.7217 31.9248 83.4434 31.8516 83.1152 31.8516C82.7695 31.8516 82.4736 31.9072 82.2275 32.0186C81.9873 32.1299 81.791 32.291 81.6387 32.502C81.4863 32.7129 81.3721 32.9648 81.2959 33.2578C81.2197 33.5508 81.1729 33.8818 81.1553 34.251V35.4727C81.1846 35.9062 81.2666 36.2959 81.4014 36.6416C81.5361 36.9814 81.7441 37.251 82.0254 37.4502C82.3066 37.6494 82.6758 37.749 83.1328 37.749C83.4668 37.749 83.748 37.6758 83.9766 37.5293C84.2051 37.377 84.3896 37.1689 84.5303 36.9053C84.6768 36.6416 84.7793 36.3369 84.8379 35.9912C84.9023 35.6455 84.9346 35.2734 84.9346 34.875Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M100.351 36.2021C100.351 35.9736 100.315 35.7686 100.245 35.5869C100.181 35.3994 100.058 35.2295 99.876 35.0771C99.6943 34.9189 99.4395 34.7637 99.1113 34.6113C98.7832 34.459 98.3584 34.3008 97.8369 34.1367C97.2568 33.9492 96.7061 33.7383 96.1846 33.5039C95.6689 33.2695 95.2119 32.9971 94.8135 32.6865C94.4209 32.3701 94.1104 32.0039 93.8818 31.5879C93.6592 31.1719 93.5479 30.6885 93.5479 30.1377C93.5479 29.6045 93.665 29.1211 93.8994 28.6875C94.1338 28.248 94.4619 27.873 94.8838 27.5625C95.3057 27.2461 95.8037 27.0029 96.3779 26.833C96.958 26.6631 97.5938 26.5781 98.2852 26.5781C99.2285 26.5781 100.052 26.748 100.755 27.0879C101.458 27.4277 102.003 27.8936 102.39 28.4854C102.782 29.0771 102.979 29.7539 102.979 30.5156H100.359C100.359 30.1406 100.28 29.8125 100.122 29.5312C99.9697 29.2441 99.7354 29.0186 99.4189 28.8545C99.1084 28.6904 98.7158 28.6084 98.2412 28.6084C97.7842 28.6084 97.4033 28.6787 97.0986 28.8193C96.7939 28.9541 96.5654 29.1387 96.4131 29.373C96.2607 29.6016 96.1846 29.8594 96.1846 30.1465C96.1846 30.3633 96.2373 30.5596 96.3428 30.7354C96.4541 30.9111 96.6182 31.0752 96.835 31.2275C97.0518 31.3799 97.3184 31.5234 97.6348 31.6582C97.9512 31.793 98.3174 31.9248 98.7334 32.0537C99.4307 32.2646 100.043 32.502 100.57 32.7656C101.104 33.0293 101.549 33.3252 101.906 33.6533C102.264 33.9814 102.533 34.3535 102.715 34.7695C102.896 35.1855 102.987 35.6572 102.987 36.1846C102.987 36.7412 102.879 37.2393 102.662 37.6787C102.445 38.1182 102.132 38.4902 101.722 38.7949C101.312 39.0996 100.822 39.3311 100.254 39.4893C99.6855 39.6475 99.0498 39.7266 98.3467 39.7266C97.7139 39.7266 97.0898 39.6445 96.4746 39.4805C95.8594 39.3105 95.2998 39.0557 94.7959 38.7158C94.2979 38.376 93.8994 37.9424 93.6006 37.415C93.3018 36.8877 93.1523 36.2637 93.1523 35.543H95.7979C95.7979 35.9414 95.8594 36.2783 95.9824 36.5537C96.1055 36.8291 96.2783 37.0518 96.501 37.2217C96.7295 37.3916 96.999 37.5146 97.3096 37.5908C97.626 37.667 97.9717 37.7051 98.3467 37.7051C98.8037 37.7051 99.1787 37.6406 99.4717 37.5117C99.7705 37.3828 99.9902 37.2041 100.131 36.9756C100.277 36.7471 100.351 36.4893 100.351 36.2021Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M109.28 30.041V31.834H103.743V30.041H109.28ZM105.114 27.6943H107.646V36.6855C107.646 36.9609 107.681 37.1719 107.751 37.3184C107.827 37.4648 107.938 37.5674 108.085 37.626C108.231 37.6787 108.416 37.7051 108.639 37.7051C108.797 37.7051 108.938 37.6992 109.061 37.6875C109.189 37.6699 109.298 37.6523 109.386 37.6348L109.395 39.498C109.178 39.5684 108.943 39.624 108.691 39.665C108.439 39.7061 108.161 39.7266 107.856 39.7266C107.3 39.7266 106.813 39.6357 106.397 39.4541C105.987 39.2666 105.671 38.9678 105.448 38.5576C105.226 38.1475 105.114 37.6084 105.114 36.9404V27.6943Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M110.089 34.8926V34.708C110.089 34.0107 110.188 33.3691 110.388 32.7832C110.587 32.1914 110.877 31.6787 111.258 31.2451C111.639 30.8115 112.107 30.4746 112.664 30.2344C113.221 29.9883 113.859 29.8652 114.58 29.8652C115.301 29.8652 115.942 29.9883 116.505 30.2344C117.067 30.4746 117.539 30.8115 117.92 31.2451C118.307 31.6787 118.6 32.1914 118.799 32.7832C118.998 33.3691 119.098 34.0107 119.098 34.708V34.8926C119.098 35.584 118.998 36.2256 118.799 36.8174C118.6 37.4033 118.307 37.916 117.92 38.3555C117.539 38.7891 117.07 39.126 116.514 39.3662C115.957 39.6064 115.318 39.7266 114.598 39.7266C113.877 39.7266 113.235 39.6064 112.673 39.3662C112.116 39.126 111.645 38.7891 111.258 38.3555C110.877 37.916 110.587 37.4033 110.388 36.8174C110.188 36.2256 110.089 35.584 110.089 34.8926ZM112.62 34.708V34.8926C112.62 35.291 112.655 35.6631 112.726 36.0088C112.796 36.3545 112.907 36.6592 113.06 36.9229C113.218 37.1807 113.423 37.3828 113.675 37.5293C113.927 37.6758 114.234 37.749 114.598 37.749C114.949 37.749 115.251 37.6758 115.503 37.5293C115.755 37.3828 115.957 37.1807 116.109 36.9229C116.262 36.6592 116.373 36.3545 116.443 36.0088C116.52 35.6631 116.558 35.291 116.558 34.8926V34.708C116.558 34.3213 116.52 33.958 116.443 33.6182C116.373 33.2725 116.259 32.9678 116.101 32.7041C115.948 32.4346 115.746 32.2236 115.494 32.0713C115.242 31.9189 114.938 31.8428 114.58 31.8428C114.223 31.8428 113.918 31.9189 113.666 32.0713C113.42 32.2236 113.218 32.4346 113.06 32.7041C112.907 32.9678 112.796 33.2725 112.726 33.6182C112.655 33.958 112.62 34.3213 112.62 34.708Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M123.185 32.1152V39.5508H120.653V30.041H123.035L123.185 32.1152ZM126.05 29.9795L126.006 32.3262C125.883 32.3086 125.733 32.2939 125.558 32.2822C125.388 32.2646 125.232 32.2559 125.092 32.2559C124.734 32.2559 124.424 32.3027 124.16 32.3965C123.902 32.4844 123.686 32.6162 123.51 32.792C123.34 32.9678 123.211 33.1816 123.123 33.4336C123.041 33.6855 122.994 33.9727 122.982 34.2949L122.473 34.1367C122.473 33.5215 122.534 32.9561 122.657 32.4404C122.78 31.9189 122.959 31.4648 123.193 31.0781C123.434 30.6914 123.727 30.3926 124.072 30.1816C124.418 29.9707 124.813 29.8652 125.259 29.8652C125.399 29.8652 125.543 29.877 125.689 29.9004C125.836 29.918 125.956 29.9443 126.05 29.9795Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M131.446 39.7266C130.708 39.7266 130.046 39.6094 129.46 39.375C128.874 39.1348 128.376 38.8037 127.966 38.3818C127.562 37.96 127.251 37.4707 127.034 36.9141C126.817 36.3516 126.709 35.7539 126.709 35.1211V34.7695C126.709 34.0488 126.812 33.3896 127.017 32.792C127.222 32.1943 127.515 31.6758 127.896 31.2363C128.282 30.7969 128.751 30.46 129.302 30.2256C129.853 29.9854 130.474 29.8652 131.165 29.8652C131.839 29.8652 132.437 29.9766 132.958 30.1992C133.479 30.4219 133.916 30.7383 134.268 31.1484C134.625 31.5586 134.895 32.0508 135.076 32.625C135.258 33.1934 135.349 33.8262 135.349 34.5234V35.5781H127.79V33.8906H132.861V33.6973C132.861 33.3457 132.797 33.0322 132.668 32.7568C132.545 32.4756 132.357 32.2529 132.105 32.0889C131.854 31.9248 131.531 31.8428 131.139 31.8428C130.805 31.8428 130.518 31.916 130.277 32.0625C130.037 32.209 129.841 32.4141 129.688 32.6777C129.542 32.9414 129.431 33.252 129.354 33.6094C129.284 33.9609 129.249 34.3477 129.249 34.7695V35.1211C129.249 35.502 129.302 35.8535 129.407 36.1758C129.519 36.498 129.674 36.7764 129.873 37.0107C130.078 37.2451 130.324 37.4268 130.611 37.5557C130.904 37.6846 131.235 37.749 131.604 37.749C132.062 37.749 132.486 37.6611 132.879 37.4854C133.277 37.3037 133.62 37.0312 133.907 36.668L135.138 38.0039C134.938 38.291 134.666 38.5664 134.32 38.8301C133.98 39.0938 133.57 39.3105 133.09 39.4805C132.609 39.6445 132.062 39.7266 131.446 39.7266Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M45.4783 28.0826C45.5269 33.0767 50.0756 34.7385 50.1259 34.7597C50.0873 34.8769 49.3991 37.128 47.7295 39.4532C46.2863 41.4635 44.7882 43.4664 42.4284 43.5079C40.11 43.5486 39.3643 42.1976 36.7134 42.1976C34.0633 42.1976 33.2349 43.4664 31.0401 43.5486C28.7623 43.6308 27.0278 41.3748 25.5726 39.3719C22.5988 35.2749 20.3263 27.7946 23.3777 22.7453C24.8936 20.2377 27.6028 18.65 30.5431 18.6092C32.7797 18.5686 34.8909 20.0432 36.2582 20.0432C37.6246 20.0432 40.1902 18.2699 42.8872 18.5303C44.0161 18.5751 47.1856 18.9648 49.2206 21.8036C49.0565 21.9005 45.4389 23.9074 45.4783 28.0826ZM41.1207 15.8198C42.3301 14.4248 43.1439 12.483 42.9219 10.5508C41.1788 10.6175 39.0711 11.6577 37.8208 13.0518C36.7003 14.2865 35.7191 16.2625 35.9839 18.1564C37.9267 18.2997 39.9114 17.2155 41.1207 15.8198Z\"\n      fill=\"#0A0A0B\"\n    />\n  </svg>\n</template>\n\n<style scoped lang=\"scss\"></style>\n","<script setup lang=\"ts\"></script>\n\n<template>\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"158\"\n    height=\"56\"\n    viewBox=\"0 0 158 56\"\n    fill=\"none\"\n  >\n    <path\n      d=\"M0.5 7.55078C0.5 3.96093 3.41015 1.05078 7 1.05078H151C154.59 1.05078 157.5 3.96093 157.5 7.55078V48.5508C157.5 52.1406 154.59 55.0508 151 55.0508H7C3.41015 55.0508 0.5 52.1406 0.5 48.5508V7.55078Z\"\n      stroke=\"#0A0A0B\"\n    />\n    <path\n      d=\"M116.915 30.0085H117.779V40.0434H116.915V30.0085ZM125.42 38.8514C125.42 39.4258 125.716 40.0434 125.716 40.0434H124.715C124.715 40.0434 124.442 39.5016 124.442 39.0031C124.442 39.0031 123.43 40.2168 121.622 40.2168C119.814 40.2168 119.075 39.3173 119.075 38.0496C119.075 36.7817 120.292 35.8822 122.759 35.8822L124.488 35.8794V34.9068C124.488 34.9068 124.51 33.2815 122.395 33.2815C120.281 33.2815 120.326 34.6874 120.326 34.6874L119.393 34.69C119.393 34.69 119.477 32.6304 122.418 32.6304C125.359 32.6304 125.42 34.8202 125.42 34.8202V38.8514ZM124.488 37.4103V36.4998H122.691C121.213 36.4998 119.996 37.1393 119.996 38.1145C119.996 39.0899 120.769 39.5126 121.702 39.5126C122.634 39.5126 124.488 38.8731 124.488 37.4103ZM126.315 32.8045H127.224L130.044 38.9744L132.788 32.8045H133.819C133.819 32.8045 130.226 40.8599 129.893 41.6183C129.559 42.377 128.763 43.0777 127.785 43.0777C127.345 43.0777 126.906 42.8322 126.906 42.8322L127.149 42.1819C127.149 42.1819 127.368 42.2976 127.8 42.2976C128.232 42.2976 128.983 41.3441 128.983 41.3441L129.529 40.1013L126.315 32.8043V32.8045ZM112.376 32.6304C114.013 32.6304 115.787 33.685 115.787 36.3656C115.787 39.0465 114.309 40.2168 112.398 40.2168C110.522 40.2168 109.679 38.903 109.65 38.8558V42.8177H108.786V32.8045H109.65V33.928C109.68 33.8926 110.761 32.6304 112.376 32.6304ZM112.239 39.545C113.831 39.545 114.9 38.1786 114.9 36.4235C114.9 34.6682 113.74 33.3245 112.353 33.3245C110.827 33.3245 109.68 34.7989 109.65 34.8379V37.9672C109.68 38.0142 110.672 39.545 112.239 39.545ZM68.2049 30.7171L66.9426 31.8512L66.3585 32.0002L66.7217 31.4331C66.7217 31.4331 65.6014 30.0304 63.6128 30.0304C61.6246 30.0304 59.3365 31.3214 59.3365 34.3726C59.3365 36.8721 61.4587 39.6101 64.7335 39.6101C65.8654 39.6101 66.6113 39.2071 66.6113 39.2071V36.969C66.6113 36.969 64.9266 36.9503 64.2914 37.1033L65.475 36.4766H68.8363C68.8363 36.4766 68.2049 36.7828 68.2049 37.6703V39.4761C68.2049 39.4761 65.7672 40.237 63.5972 40.237C59.3996 40.237 57.7109 37.2973 57.7109 34.9694C57.7109 32.3061 59.944 29.4935 63.7866 29.4935C66.9428 29.4935 68.2049 30.7171 68.2049 30.7171ZM73.547 32.6591C75.7996 32.6591 77.4683 34.1539 77.4683 36.3485C77.4683 38.5431 75.7495 40.1013 73.2966 40.1013C70.8443 40.1013 69.4594 38.1295 69.4594 36.4916C69.4594 34.2173 71.2946 32.6591 73.547 32.6591ZM73.7137 39.6241C75.5729 39.6241 75.8329 37.8113 75.8327 37.0799C75.8327 34.9563 74.7148 33.1363 73.0963 33.1363C71.962 33.1363 70.9775 34.1221 70.9775 35.5056C70.9775 36.8892 71.855 39.6241 73.7137 39.6241ZM82.3117 32.6629C84.5633 32.6629 86.2308 34.157 86.2308 36.3506C86.2308 38.5443 84.5134 40.1015 82.0615 40.1015C79.61 40.1015 78.2259 38.1305 78.2259 36.4935C78.2259 34.2205 80.0603 32.6629 82.3117 32.6629ZM82.4783 39.6243C84.3367 39.6243 84.5967 37.8125 84.5967 37.0813C84.5967 34.9592 83.4794 33.1397 81.8614 33.1397C80.7277 33.1397 79.7434 34.1252 79.7434 35.5079C79.7434 36.8906 80.6207 39.6245 82.4783 39.6245V39.6243ZM92.6988 39.5737C93.503 40.1032 94.0578 40.8574 94.0582 41.8482C94.0582 43.9258 91.3483 44.739 89.7655 44.739C88.1827 44.739 86.2518 44.1266 86.2518 42.4961C86.2518 39.7991 90.6687 39.7952 90.6687 39.7952C90.6687 39.7952 90.1966 39.3293 90.1966 38.8079C90.1966 38.4881 90.3124 38.247 90.3124 38.247C90.3124 38.247 90.1799 38.2866 89.981 38.2866C88.0666 38.2866 87.0971 36.9834 87.0971 35.8938C87.0971 34.3458 88.5721 32.9083 90.5279 32.9083H94.3396L93.3618 33.4611L92.3841 33.4925C92.3841 33.4925 93.4118 34.14 93.4118 35.5935C93.4118 36.5729 92.8892 37.114 92.3174 37.6313C91.7459 38.1486 91.7375 38.3341 91.7375 38.5629C91.7375 38.7921 91.8949 39.045 92.6986 39.5737H92.6988ZM90.602 37.8127C91.7585 37.8127 91.9817 36.948 91.9817 36.3082C91.9817 34.4719 90.8884 33.4648 89.9682 33.4648C89.0484 33.4648 88.5263 34.1758 88.5263 35.171C88.5263 36.1662 89.4462 37.8127 90.6022 37.8127H90.602ZM90.5153 44.0678C91.0495 44.0678 92.9017 43.9258 92.9017 42.3973C92.9017 41.3315 92.0071 40.9937 91.1987 40.3125C91.1987 40.3125 90.9379 40.271 90.6332 40.271C90.3284 40.271 87.7062 40.4311 87.7062 42.1488C87.7062 43.8664 89.9808 44.0678 90.5153 44.0678ZM94.1443 29.5222L95.2346 28.9551H97.6268C97.0692 29.2387 96.8603 29.4632 96.846 30.786L96.7591 38.8455C96.7591 39.3499 97.2192 39.4864 97.6338 39.4864C98.0112 39.4864 98.1841 39.5562 98.1841 39.5562L97.6763 39.8929H94.7761C94.7761 39.8929 95.1925 39.5381 95.1975 39.1841L95.3464 29.5251L94.1443 29.5222ZM104.722 34.5937L100.92 36.0465L99.6304 36.1104C99.6304 36.1104 102.855 34.8573 102.98 34.6417C103.106 34.4265 102.847 33.205 101.423 33.205C100.713 33.205 99.5798 33.8273 99.5798 35.3762C99.5798 37.6747 101.389 39.2393 102.947 39.2393C103.985 39.2393 104.923 38.7123 104.923 38.7123C104.923 38.7123 104.036 40.1013 102.075 40.1013C99.2785 40.1013 98.1562 38.0736 98.1562 36.2701C98.1562 34.4662 99.4295 32.6304 101.875 32.6304C104.32 32.6304 104.722 34.5937 104.722 34.5937H104.722Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M23.3125 14.4225C23.3125 13.5771 24.1024 13.1096 24.4973 12.9814L38.2666 26.6228L24.4653 40.168C23.9785 40.1424 23.4939 39.218 23.3125 38.759V14.4225Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M42.6856 22.2038L27.6034 13.75L39.4835 25.438L42.6856 22.2038Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M45.6744 24.0367L44.1586 23.1324L40.7003 26.6228L44.2186 30.0016L45.597 29.2339C47.6159 28.1095 47.6589 25.2207 45.6744 24.0367Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M42.6856 30.9115L39.4835 27.783L27.6031 39.5094L42.6856 30.9115Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M63.7441 24.2061C63.5358 24.5023 63.2087 24.7334 62.7627 24.8994C62.32 25.0654 61.8236 25.1484 61.2734 25.1484C60.7168 25.1484 60.222 25.015 59.7891 24.748C59.3561 24.4811 59.0208 24.1035 58.7832 23.6152C58.5456 23.127 58.4251 22.5671 58.4219 21.9355V21.0371C58.4219 20.0508 58.6709 19.2728 59.1689 18.7031C59.667 18.1302 60.3359 17.8438 61.1758 17.8438C61.9082 17.8438 62.4974 18.0309 62.9434 18.4053C63.3893 18.7764 63.6546 19.2891 63.7393 19.9434H63.1387C63.0508 19.4225 62.8376 19.0286 62.499 18.7617C62.1637 18.4915 61.7243 18.3564 61.1807 18.3564C60.5166 18.3564 59.9909 18.5924 59.6035 19.0645C59.2161 19.5365 59.0225 20.2021 59.0225 21.0615V21.9014C59.0225 22.4417 59.1136 22.9202 59.2959 23.3369C59.4814 23.7503 59.7451 24.071 60.0869 24.2988C60.432 24.5267 60.8275 24.6406 61.2734 24.6406C61.791 24.6406 62.2354 24.5592 62.6064 24.3965C62.8473 24.2891 63.0264 24.1637 63.1436 24.0205V22.1846H61.2344V21.6768H63.7441V24.2061Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M67.3574 25.1484C66.9082 25.1484 66.5013 25.0378 66.1367 24.8164C65.7754 24.5951 65.4938 24.2874 65.292 23.8936C65.0902 23.4964 64.9893 23.0521 64.9893 22.5605V22.3506C64.9893 21.8428 65.0869 21.3854 65.2822 20.9785C65.4808 20.5716 65.7559 20.2526 66.1074 20.0215C66.459 19.7871 66.8398 19.6699 67.25 19.6699C67.8913 19.6699 68.3991 19.8896 68.7734 20.3291C69.151 20.7653 69.3398 21.3626 69.3398 22.1211V22.4482H65.5703V22.5605C65.5703 23.1595 65.7412 23.6592 66.083 24.0596C66.4281 24.4567 66.861 24.6553 67.3818 24.6553C67.6943 24.6553 67.9694 24.5983 68.207 24.4844C68.4479 24.3704 68.666 24.1882 68.8613 23.9375L69.2275 24.2158C68.7979 24.8376 68.1745 25.1484 67.3574 25.1484ZM67.25 20.168C66.8105 20.168 66.4395 20.3291 66.1367 20.6514C65.8372 20.9736 65.6549 21.4066 65.5898 21.9502H68.7588V21.8867C68.7425 21.3789 68.5977 20.9655 68.3242 20.6465C68.0508 20.3275 67.6927 20.168 67.25 20.168Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M71.3857 18.415V19.7676H72.4795V20.2461H71.3857V23.7666C71.3857 24.0596 71.4378 24.2777 71.542 24.4209C71.6494 24.5641 71.8268 24.6357 72.0742 24.6357C72.1719 24.6357 72.3298 24.6195 72.5479 24.5869L72.5723 25.0654C72.4193 25.1208 72.2109 25.1484 71.9473 25.1484C71.5469 25.1484 71.2555 25.0329 71.0732 24.8018C70.891 24.5674 70.7998 24.224 70.7998 23.7715V20.2461H69.8281V19.7676H70.7998V18.415H71.3857Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M76.7764 25.0508H76.1904V19.7676H76.7764V25.0508ZM76.0879 18.2393C76.0879 18.1286 76.1237 18.0358 76.1953 17.9609C76.2669 17.8828 76.3646 17.8438 76.4883 17.8438C76.612 17.8438 76.7096 17.8828 76.7812 17.9609C76.8561 18.0358 76.8936 18.1286 76.8936 18.2393C76.8936 18.3499 76.8561 18.4427 76.7812 18.5176C76.7096 18.5924 76.612 18.6299 76.4883 18.6299C76.3646 18.6299 76.2669 18.5924 76.1953 18.5176C76.1237 18.4427 76.0879 18.3499 76.0879 18.2393Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M79.2764 18.415V19.7676H80.3701V20.2461H79.2764V23.7666C79.2764 24.0596 79.3285 24.2777 79.4326 24.4209C79.54 24.5641 79.7174 24.6357 79.9648 24.6357C80.0625 24.6357 80.2204 24.6195 80.4385 24.5869L80.4629 25.0654C80.3099 25.1208 80.1016 25.1484 79.8379 25.1484C79.4375 25.1484 79.1462 25.0329 78.9639 24.8018C78.7816 24.5674 78.6904 24.224 78.6904 23.7715V20.2461H77.7188V19.7676H78.6904V18.415H79.2764Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M83.6904 22.3311C83.6904 21.8232 83.7881 21.3659 83.9834 20.959C84.182 20.5521 84.4603 20.2363 84.8184 20.0117C85.1797 19.7839 85.5882 19.6699 86.0439 19.6699C86.7471 19.6699 87.3167 19.9173 87.7529 20.4121C88.1891 20.9036 88.4072 21.5563 88.4072 22.3701V22.4922C88.4072 23.0033 88.3079 23.4639 88.1094 23.874C87.9141 24.2809 87.6374 24.5951 87.2793 24.8164C86.9212 25.0378 86.5127 25.1484 86.0537 25.1484C85.3538 25.1484 84.7842 24.9027 84.3447 24.4111C83.9085 23.9163 83.6904 23.262 83.6904 22.4482V22.3311ZM84.2764 22.4922C84.2764 23.1237 84.4391 23.6429 84.7646 24.0498C85.0934 24.4535 85.5231 24.6553 86.0537 24.6553C86.5811 24.6553 87.0075 24.4535 87.333 24.0498C87.6618 23.6429 87.8262 23.1074 87.8262 22.4434V22.3311C87.8262 21.9274 87.7513 21.5579 87.6016 21.2227C87.4518 20.8874 87.2419 20.6286 86.9717 20.4463C86.7015 20.2607 86.3923 20.168 86.0439 20.168C85.5231 20.168 85.0983 20.373 84.7695 20.7832C84.4408 21.1901 84.2764 21.724 84.2764 22.3848V22.4922Z\"\n      fill=\"#0A0A0B\"\n    />\n    <path\n      d=\"M90.1748 19.7676L90.1943 20.6709C90.3929 20.3454 90.6403 20.098 90.9365 19.9287C91.2327 19.7562 91.5599 19.6699 91.918 19.6699C92.4844 19.6699 92.9059 19.8294 93.1826 20.1484C93.4593 20.4674 93.5993 20.946 93.6025 21.584V25.0508H93.0215V21.5791C93.0182 21.1071 92.9173 20.7555 92.7188 20.5244C92.5234 20.2933 92.2093 20.1777 91.7764 20.1777C91.415 20.1777 91.0944 20.2917 90.8145 20.5195C90.5378 20.7441 90.3327 21.0485 90.1992 21.4326V25.0508H89.6182V19.7676H90.1748Z\"\n      fill=\"#0A0A0B\"\n    />\n  </svg>\n</template>\n\n<style scoped lang=\"scss\"></style>\n","<script setup lang=\"ts\">\nimport Container from '~/components/global/Container.vue'\nimport IconDownloadWindows from '~/components/icons/IconDownloadWindows.vue'\nimport IconDownloadMacOs from '~/components/icons/IconDownloadMacOs.vue'\nimport IconDownloadAppStore from '~/components/icons/IconDownloadAppStore.vue'\nimport IconDownloadGooglePlay from '~/components/icons/IconDownloadGooglePlay.vue'\nimport { PLATFORM_LINKS, DOWNLOAD_LINKS } from '~/constants/links'\nimport { RoutesPathsEnum } from '~/enums/routes'\nimport { useMenu } from '~/composables/useMenu'\n\nconst fullYear = new Date().getFullYear()\nconst { menuList } = useMenu()\n</script>\n\n<template>\n  <footer class=\"footer\">\n    <Container>\n      <div class=\"footer-download\">\n        <NuxtLinkLocale\n          :to=\"RoutesPathsEnum.MAIN\"\n          class=\"footer-download__logo\"\n        >\n          <NuxtImg src=\"/images/logo.svg\" alt=\"Logo\" width=\"235\" height=\"54\" />\n        </NuxtLinkLocale>\n        <p>{{ $t('footer.download') }}</p>\n        <div class=\"footer-download__buttons\">\n          <a :href=\"PLATFORM_LINKS.ANDROID\" target=\"_blank\">\n            <IconDownloadGooglePlay />\n          </a>\n          <a :href=\"PLATFORM_LINKS.IOS\" target=\"_blank\">\n            <IconDownloadAppStore />\n          </a>\n          <a :href=\"DOWNLOAD_LINKS.WINDOWS\" target=\"_blank\">\n            <IconDownloadWindows />\n          </a>\n          <a :href=\"DOWNLOAD_LINKS.OSX\" target=\"_blank\">\n            <IconDownloadMacOs />\n          </a>\n        </div>\n      </div>\n\n      <div class=\"footer-menu\">\n        <div\n          v-for=\"item in menuList\"\n          :key=\"item.title\"\n          class=\"footer-menu__col\"\n        >\n          <h4>{{ item.title }}</h4>\n          <NuxtLinkLocale\n            v-for=\"link in item.links\"\n            :key=\"link.slug\"\n            :to=\"link.link\"\n          >\n            {{ link.title }}\n          </NuxtLinkLocale>\n        </div>\n      </div>\n\n      <p class=\"footer__address\">\n        {{ $t('footer.address') }}\n      </p>\n      <p class=\"footer__copy\">\n         {{ fullYear }} VPNLY. {{ $t('footer.copyright') }}\n      </p>\n    </Container>\n  </footer>\n</template>\n\n<style scoped lang=\"scss\">\n.footer {\n  padding: 40px 0;\n\n  @media (min-width: 768px) {\n    padding: 80px 0;\n  }\n\n  &-download {\n    display: flex;\n    flex-direction: column;\n    margin-bottom: 40px;\n    gap: 20px;\n\n    @media (min-width: 768px) {\n      flex-direction: row;\n      flex-wrap: wrap;\n      align-items: center;\n      margin-bottom: 80px;\n    }\n\n    @media (min-width: 1200px) {\n      flex-wrap: nowrap;\n    }\n\n    &__logo {\n      display: none;\n\n      @media (min-width: 768px) {\n        display: block;\n        max-width: 235px;\n        flex-shrink: 0;\n      }\n    }\n\n    p {\n      font-size: 16px;\n      color: var(--gray-9);\n\n      @media (min-width: 768px) {\n        max-width: 50%;\n      }\n\n      @media (min-width: 1200px) {\n        max-width: 335px;\n      }\n    }\n\n    &__buttons {\n      display: grid;\n      grid-template-columns: repeat(2, 1fr);\n      grid-gap: 20px;\n      max-width: 340px;\n\n      @media (min-width: 576px) {\n        grid-template-columns: repeat(4, 1fr);\n        grid-gap: 16px;\n        max-width: none;\n      }\n\n      a {\n        display: flex;\n      }\n\n      &:deep(svg) {\n        max-width: 100%;\n        height: auto;\n        cursor: pointer;\n\n        path {\n          transition: var(--base-transition);\n        }\n\n        &:hover {\n          fill: var(--gray-1);\n\n          path[fill='#0A0A0B'] {\n            fill: var(--white);\n            transition: var(--base-transition);\n          }\n        }\n      }\n    }\n  }\n\n  &-menu {\n    display: grid;\n    grid-template-columns: max-content;\n    grid-row-gap: 40px;\n    margin-bottom: 40px;\n\n    @media (min-width: 576px) {\n      grid-template-columns: repeat(2, 1fr);\n    }\n\n    @media (min-width: 992px) {\n      grid-template-columns: repeat(4, 1fr);\n      grid-column-gap: 20px;\n    }\n\n    &__col {\n      h4 {\n        margin-bottom: 10px;\n        font-weight: 600;\n\n        @media (min-width: 576px) {\n          margin-bottom: 30px;\n          font-weight: 700;\n        }\n      }\n\n      a {\n        display: block;\n        font-size: 16px;\n        color: var(--gray-6);\n        margin-bottom: 20px;\n        transition: var(--base-transition);\n\n        &:last-child {\n          margin-bottom: 0;\n        }\n\n        &:hover {\n          color: var(--orange-default);\n        }\n      }\n    }\n  }\n\n  &__address {\n    max-width: 934px;\n    font-size: 16px;\n    margin-bottom: 10px;\n    color: var(--gray-9);\n  }\n\n  &__copy {\n    font-size: 16px;\n    color: var(--gray-12);\n  }\n}\n</style>\n","import { watch } from 'vue'\nimport { useRoute } from 'vue-router'\n\nimport { RoutesPathsEnum } from '~/enums/routes'\nimport { useThemeStore } from '~/store/theme'\n\nexport const useDarkThemeProvider = () => {\n  const route = useRoute()\n  const themeStore = useThemeStore()\n\n  watch(\n    () => route.path,\n    (routePath) => {\n      if (routePath.includes(RoutesPathsEnum.DONATE)) {\n        themeStore.setDarkTheme()\n      } else {\n        themeStore.removeDarkTheme()\n      }\n    },\n    { immediate: true },\n  )\n}\n","import { onMounted } from 'vue'\nimport { useRouter } from 'vue-router'\n\nimport { useMenuStore } from '~/store/menu'\n\nexport const useMobileMenuProvider = () => {\n  const router = useRouter()\n  const menuStore = useMenuStore()\n\n  onMounted(() => {\n    router.beforeEach((to, from, next) => {\n      if (menuStore.isMenuOpen) {\n        menuStore.closeMenu()\n      }\n      next()\n    })\n  })\n}\n","<script setup lang=\"ts\">\nimport { useLocaleHead } from '#i18n'\nimport { useHead } from 'unhead'\n\nimport Header from '~/components/app/Header/Header.vue'\nimport Footer from '~/components/app/Footer/Footer.vue'\nimport { useDarkThemeProvider } from '~/composables/useDarkTheme'\nimport { useMobileMenuProvider } from '~/composables/useMobileMenu'\n\nconst i18nHead = useLocaleHead({\n  addDirAttribute: true,\n  identifierAttribute: 'id',\n  addSeoAttributes: true,\n})\n\nuseHead({\n  htmlAttrs: {\n    lang: i18nHead.value.htmlAttrs!.lang,\n    dir: i18nHead.value.htmlAttrs.dir,\n  },\n  link: [...(i18nHead.value.link || [])],\n  meta: [...(i18nHead.value.meta || [])],\n})\n\nuseDarkThemeProvider()\nuseMobileMenuProvider()\n</script>\n\n<template>\n  <Header />\n  <main class=\"main\">\n    <NuxtPage />\n  </main>\n  <Footer />\n</template>\n\n<style lang=\"scss\" scoped>\n.main {\n  margin-top: var(--header-height);\n}\n</style>\n"],"names":["unrefElement","defaultWindow","useEventListener","events","onClickOutside","window","_sfc_ssrRender","_ssrRenderAttrs","_mergeProps","_ssrRenderSlot","LocalesCodesEnum","localesList"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,SAAS,kBAAkB,IAAI;AAC7B,MAAI,mBAAmB;AACrB,mBAAe,EAAE;AACV,WAAA;AAAA,EACT;AACO,SAAA;AACT;AA2JA,SAAS,QAAQ,GAAG;AAClB,SAAO,OAAO,MAAM,aAAa,EAAE,IAAI,MAAM,CAAC;AAChD;AA6EiB,OAAO,sBAAsB,eAAe,sBAAsB;AAOnF,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,WAAW,CAAC,QAAQ,SAAS,KAAK,GAAG,MAAM;AAIjD,MAAM,OAAO,MAAM;AACnB;AAsIA,MAAM,iBAAiB;AAAA,EACrB,SAAkB;AAAA,EAClB,SAAkB;AAAA,EAClB,WAAoB;AACtB;AAgFA,SAAS,SAAS,MAAM;AACtB,MAAI,KAAK,WAAW;AACX,WAAA,QAAQ,GAAG,IAAI;AAClB,QAAA,IAAI,KAAK,CAAC;AAChB,SAAO,OAAO,MAAM,aAAa,SAAS,UAAU,OAAO,EAAE,KAAK,GAAG,KAAK,KAAK,EAAE,CAAC,IAAI,IAAI,CAAC;AAC7F;AAwxBA,SAAS,UAAU,eAAe,OAAO,UAAU,CAAA,GAAI;AAC/C,QAAA;AAAA,IACJ,cAAc;AAAA,IACd,aAAa;AAAA,EACX,IAAA;AACE,QAAA,aAAa,MAAM,YAAY;AAC/B,QAAA,SAAS,IAAI,YAAY;AAC/B,WAAS,OAAO,OAAO;AACrB,QAAI,UAAU,QAAQ;AACpB,aAAO,QAAQ;AACf,aAAO,OAAO;AAAA,IAAA,OACT;AACC,YAAA,SAAS,QAAQ,WAAW;AAClC,aAAO,QAAQ,OAAO,UAAU,SAAS,QAAQ,UAAU,IAAI;AAC/D,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AACI,MAAA;AACK,WAAA;AAAA;AAEA,WAAA,CAAC,QAAQ,MAAM;AAC1B;ACvoCA,SAASA,eAAa,OAAO;AACvB,MAAA;AACE,QAAA,QAAQ,QAAQ,KAAK;AAC3B,UAAQ,KAAK,SAAS,OAAO,SAAS,MAAM,QAAQ,OAAO,KAAK;AAClE;AAEA,MAAMC,kBAAoC;AAK1C,SAASC,sBAAoB,MAAM;AAC7B,MAAA;AACAC,MAAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA,OAAO,KAAK,CAAC,MAAM,YAAY,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AACxDA,KAAAA,SAAQ,WAAW,OAAO,IAAI;AACtB,aAAAF;AAAAA,EAAA,OACJ;AACL,KAAC,QAAQE,SAAQ,WAAW,OAAO,IAAI;AAAA,EACzC;AACA,MAAI,CAAC;AACI,WAAA;AACL,MAAA,CAAC,MAAM,QAAQA,OAAM;AACvBA,cAAS,CAACA,OAAM;AACd,MAAA,CAAC,MAAM,QAAQ,SAAS;AAC1B,gBAAY,CAAC,SAAS;AACxB,QAAM,WAAW,CAAA;AACjB,QAAM,UAAU,MAAM;AACpB,aAAS,QAAQ,CAAC,OAAO,GAAI,CAAA;AAC7B,aAAS,SAAS;AAAA,EAAA;AAEpB,QAAM,WAAW,CAAC,IAAI,OAAO,UAAU,aAAa;AAC/C,OAAA,iBAAiB,OAAO,UAAU,QAAQ;AAC7C,WAAO,MAAM,GAAG,oBAAoB,OAAO,UAAU,QAAQ;AAAA,EAAA;AAE/D,QAAM,YAAY;AAAA,IAChB,MAAM,CAACH,eAAa,MAAM,GAAG,QAAQ,OAAO,CAAC;AAAA,IAC7C,CAAC,CAAC,IAAI,QAAQ,MAAM;AACV;AACR,UAAI,CAAC;AACH;AACF,YAAM,eAAe,SAAS,QAAQ,IAAI,EAAE,GAAG,SAAa,IAAA;AACnD,eAAA;AAAA,QACP,GAAGG,QAAO,QAAQ,CAAC,UAAU;AACpB,iBAAA,UAAU,IAAI,CAAC,aAAa,SAAS,IAAI,OAAO,UAAU,YAAY,CAAC;AAAA,QAAA,CAC/E;AAAA,MAAA;AAAA,IAEL;AAAA,IACA,EAAE,WAAW,MAAM,OAAO,OAAO;AAAA,EAAA;AAEnC,QAAM,OAAO,MAAM;AACP;AACF;EAAA;AAEV,oBAAkB,IAAI;AACf,SAAA;AACT;AAGA,SAASC,iBAAe,QAAQ,SAAS,UAAU,CAAA,GAAI;AAC/C,QAAA,EAAE,QAAAC,UAASJ,iBAAe,SAAS,CAAA,GAAI,UAAU,MAAM,eAAe,MAAA,IAAU;AACtF,MAAI,CAACI;AACI,WAAA;AAMT,MAAI,eAAe;AACb,QAAA,eAAe,CAAC,UAAU;AACvB,WAAA,OAAO,KAAK,CAAC,YAAY;AAC1B,UAAA,OAAO,YAAY,UAAU;AAC/B,eAAO,MAAM,KAAKA,QAAO,SAAS,iBAAiB,OAAO,CAAC,EAAE,KAAK,CAAC,OAAO,OAAO,MAAM,UAAU,MAAM,eAAe,SAAS,EAAE,CAAC;AAAA,MAAA,OAC7H;AACC,cAAA,KAAKL,eAAa,OAAO;AACxB,eAAA,OAAO,MAAM,WAAW,MAAM,MAAM,eAAe,SAAS,EAAE;AAAA,MACvE;AAAA,IAAA,CACD;AAAA,EAAA;AAEG,QAAA,WAAW,CAAC,UAAU;AACpB,UAAA,KAAKA,eAAa,MAAM;AAC1B,QAAA,CAAC,MAAM,OAAO,MAAM,UAAU,MAAM,aAAA,EAAe,SAAS,EAAE;AAChE;AACF,QAAI,MAAM,WAAW;AACJ,qBAAA,CAAC,aAAa,KAAK;AACpC,QAAI,CAAC,cAAc;AACF,qBAAA;AACf;AAAA,IACF;AACA,YAAQ,KAAK;AAAA,EAAA;AAEf,QAAM,UAAU;AAAA,IACdE,mBAAiBG,SAAQ,SAAS,UAAU,EAAE,SAAS,MAAM,SAAS;AAAA,IACtEH,mBAAiBG,SAAQ,eAAe,CAAC,MAAM;AACvC,YAAA,KAAKL,eAAa,MAAM;AAC9B,qBAAe,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,EAAE,aAAe,EAAA,SAAS,EAAE;AAAA,IAAA,GACxE,EAAE,SAAS,MAAM;AAAA,IACpB,gBAAgBE,mBAAiBG,SAAQ,QAAQ,CAAC,UAAU;AAC1D,iBAAW,MAAM;AACX,YAAA;AACE,cAAA,KAAKL,eAAa,MAAM;AAC9B,cAAM,KAAKK,QAAO,SAAS,kBAAkB,OAAO,SAAS,GAAG,aAAa,YAAY,EAAE,MAAM,OAAO,SAAS,GAAG,SAASA,QAAO,SAAS,aAAa,IAAI;AAC5J,kBAAQ,KAAK;AAAA,QACf;AAAA,SACC,CAAC;AAAA,IAAA,CACL;AAAA,EAAA,EACD,OAAO,OAAO;AAChB,QAAM,OAAO,MAAM,QAAQ,QAAQ,CAAC,OAAO,IAAI;AACxC,SAAA;AACT;AC7QA,SAAS,aAAa,OAAO;AACvB,MAAA;AACE,QAAA,QAAQ,QAAQ,KAAK;AAC3B,UAAQ,KAAK,SAAS,OAAO,SAAS,MAAM,QAAQ,OAAO,KAAK;AAClE;AAEA,MAAM,gBAAoC;AAE1C,SAAS,oBAAoB,MAAM;AAC7B,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA,OAAO,KAAK,CAAC,MAAM,YAAY,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AACxD,KAAA,QAAQ,WAAW,OAAO,IAAI;AACtB,aAAA;AAAA,EAAA,OACJ;AACL,KAAC,QAAQ,QAAQ,WAAW,OAAO,IAAI;AAAA,EACzC;AACA,MAAI,CAAC;AACI,WAAA;AACL,MAAA,CAAC,MAAM,QAAQ,MAAM;AACvB,aAAS,CAAC,MAAM;AACd,MAAA,CAAC,MAAM,QAAQ,SAAS;AAC1B,gBAAY,CAAC,SAAS;AACxB,QAAM,WAAW,CAAA;AACjB,QAAM,UAAU,MAAM;AACpB,aAAS,QAAQ,CAAC,OAAO,GAAI,CAAA;AAC7B,aAAS,SAAS;AAAA,EAAA;AAEpB,QAAM,WAAW,CAAC,IAAI,OAAO,UAAU,aAAa;AAC/C,OAAA,iBAAiB,OAAO,UAAU,QAAQ;AAC7C,WAAO,MAAM,GAAG,oBAAoB,OAAO,UAAU,QAAQ;AAAA,EAAA;AAE/D,QAAM,YAAY;AAAA,IAChB,MAAM,CAAC,aAAa,MAAM,GAAG,QAAQ,OAAO,CAAC;AAAA,IAC7C,CAAC,CAAC,IAAI,QAAQ,MAAM;AACV;AACR,UAAI,CAAC;AACH;AACF,YAAM,eAAe,SAAS,QAAQ,IAAI,EAAE,GAAG,SAAa,IAAA;AACnD,eAAA;AAAA,QACP,GAAG,OAAO,QAAQ,CAAC,UAAU;AACpB,iBAAA,UAAU,IAAI,CAAC,aAAa,SAAS,IAAI,OAAO,UAAU,YAAY,CAAC;AAAA,QAAA,CAC/E;AAAA,MAAA;AAAA,IAEL;AAAA,IACA,EAAE,WAAW,MAAM,OAAO,OAAO;AAAA,EAAA;AAEnC,QAAM,OAAO,MAAM;AACP;AACF;EAAA;AAEV,oBAAkB,IAAI;AACf,SAAA;AACT;AAGA,SAAS,eAAe,QAAQ,SAAS,UAAU,CAAA,GAAI;AAC/C,QAAA,EAAE,QAAAA,UAAS,eAAe,SAAS,CAAA,GAAI,UAAU,MAAM,eAAe,MAAA,IAAU;AACtF,MAAI,CAACA;AACI,WAAA;AAMT,MAAI,eAAe;AACb,QAAA,eAAe,CAAC,UAAU;AACvB,WAAA,OAAO,KAAK,CAAC,YAAY;AAC1B,UAAA,OAAO,YAAY,UAAU;AAC/B,eAAO,MAAM,KAAKA,QAAO,SAAS,iBAAiB,OAAO,CAAC,EAAE,KAAK,CAAC,OAAO,OAAO,MAAM,UAAU,MAAM,eAAe,SAAS,EAAE,CAAC;AAAA,MAAA,OAC7H;AACC,cAAA,KAAK,aAAa,OAAO;AACxB,eAAA,OAAO,MAAM,WAAW,MAAM,MAAM,eAAe,SAAS,EAAE;AAAA,MACvE;AAAA,IAAA,CACD;AAAA,EAAA;AAEG,QAAA,WAAW,CAAC,UAAU;AACpB,UAAA,KAAK,aAAa,MAAM;AAC1B,QAAA,CAAC,MAAM,OAAO,MAAM,UAAU,MAAM,aAAA,EAAe,SAAS,EAAE;AAChE;AACF,QAAI,MAAM,WAAW;AACJ,qBAAA,CAAC,aAAa,KAAK;AACpC,QAAI,CAAC,cAAc;AACF,qBAAA;AACf;AAAA,IACF;AACA,YAAQ,KAAK;AAAA,EAAA;AAEf,QAAM,UAAU;AAAA,IACd,iBAAiBA,SAAQ,SAAS,UAAU,EAAE,SAAS,MAAM,SAAS;AAAA,IACtE,iBAAiBA,SAAQ,eAAe,CAAC,MAAM;AACvC,YAAA,KAAK,aAAa,MAAM;AAC9B,qBAAe,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,EAAE,aAAe,EAAA,SAAS,EAAE;AAAA,IAAA,GACxE,EAAE,SAAS,MAAM;AAAA,IACpB,gBAAgB,iBAAiBA,SAAQ,QAAQ,CAAC,UAAU;AAC1D,iBAAW,MAAM;AACX,YAAA;AACE,cAAA,KAAK,aAAa,MAAM;AAC9B,cAAM,KAAKA,QAAO,SAAS,kBAAkB,OAAO,SAAS,GAAG,aAAa,YAAY,EAAE,MAAM,OAAO,SAAS,GAAG,SAASA,QAAO,SAAS,aAAa,IAAI;AAC5J,kBAAQ,KAAK;AAAA,QACf;AAAA,SACC,CAAC;AAAA,IAAA,CACL;AAAA,EAAA,EACD,OAAO,OAAO;AAChB,QAAM,OAAO,MAAM,QAAQ,QAAQ,CAAC,OAAO,IAAI;AACxC,SAAA;AACT;AAEA,MAAM,kBAAkB;AAAA,EACtB,CAAC,eAAe,OAAO,EAAE,IAAI,SAAS;AAC9B,UAAA,UAAU,CAAC,QAAQ,UAAU;AAC/B,QAAA,OAAO,QAAQ,UAAU,YAAY;AACvC,SAAG,wBAAwB,eAAe,IAAI,QAAQ,OAAO,EAAE,SAAS;AAAA,IAAA,OACnE;AACL,YAAM,CAAC,SAAS,OAAO,IAAI,QAAQ;AAChC,SAAA,wBAAwB,eAAe,IAAI,SAAS,OAAO,OAAO,EAAE,WAAW,OAAO,CAAC;AAAA,IAC5F;AAAA,EACF;AAAA,EACA,CAAC,eAAe,SAAS,EAAE,IAAI;AAC7B,OAAG,sBAAsB;AAAA,EAC3B;AACF;AA2xCA,SAAS,eAAe,IAAI;AACtB,MAAA,OAAO,WAAW,eAAe,cAAc;AACjD,WAAO,GAAG,SAAS;AACjB,MAAA,OAAO,aAAa,eAAe,cAAc;AACnD,WAAO,GAAG;AACL,SAAA;AACT;AAqgBA,MAAM,wCAAwC;AAC9C,SAAS,cAAc,SAAS,eAAe,OAAO;AAC9C,QAAA,WAAW,IAAI,YAAY;AAEjC,MAAI,kBAAkB;AACtB,QAAM,MAAM,OAAO,GAAG,CAAC,OAAO;AAC5B,UAAM,SAAS,eAAe,QAAQ,EAAE,CAAC;AACzC,QAAI,QAAQ;AACV,YAAM,MAAM;AACR,UAAA,CAAC,kBAAkB,IAAI,GAAG;AAC5B,0BAAkB,IAAI,KAAK,IAAI,MAAM,QAAQ;AAC3C,UAAA,IAAI,MAAM,aAAa;AACzB,0BAAkB,IAAI,MAAM;AAC1B,UAAA,IAAI,MAAM,aAAa;AACzB,eAAO,SAAS,QAAQ;AAC1B,UAAI,SAAS;AACJ,eAAA,IAAI,MAAM,WAAW;AAAA,IAChC;AAAA,EAAA,GACC;AAAA,IACD,WAAW;AAAA,EAAA,CACZ;AACD,QAAM,OAAO,MAAM;AACjB,UAAM,KAAK,eAAe,QAAQ,OAAO,CAAC;AACtC,QAAA,CAAC,MAAM,SAAS;AAClB;AAWF,OAAG,MAAM,WAAW;AACpB,aAAS,QAAQ;AAAA,EAAA;AAEnB,QAAM,SAAS,MAAM;AACnB,UAAM,KAAK,eAAe,QAAQ,OAAO,CAAC;AACtC,QAAA,CAAC,MAAM,CAAC,SAAS;AACnB;AAEF,OAAG,MAAM,WAAW;AACpB,sBAAkB,OAAO,EAAE;AAC3B,aAAS,QAAQ;AAAA,EAAA;AAEnB,oBAAkB,MAAM;AACxB,SAAO,SAAS;AAAA,IACd,MAAM;AACJ,aAAO,SAAS;AAAA,IAClB;AAAA,IACA,IAAI,GAAG;AACD,UAAA;AACG;UACK;IACd;AAAA,EAAA,CACD;AACH;AAEA,SAAS,eAAe;AACtB,MAAI,YAAY;AACV,QAAA,QAAQ,IAAI,KAAK;AAChB,SAAA,CAAC,IAAI,YAAY;AACtB,UAAM,QAAQ,QAAQ;AAClB,QAAA;AACF;AACU,gBAAA;AACZ,UAAM,WAAW,cAAc,IAAI,QAAQ,KAAK;AAChD,UAAM,OAAO,CAAC,MAAM,SAAS,QAAQ,CAAC;AAAA,EAAA;AAE1C;AACoB,aAAa;;;;;;;;;;;;ACh/D3B,UAAA,iBAAiB,CAAC,UAAiC;AAAA,MACvD,MAAM;AAAA,QACJ,KAAK,yBAAyB,IAAI;AAAA,QAClC,KAAK,KAAK,OAAO,CAAC,EAAE,gBAAgB,KAAK,MAAM,CAAC;AAAA,MAClD;AAAA,MACA,OAAO;AAAA,QACL,KAAK,oBAAoB,IAAI;AAAA,QAC7B,KAAK,KAAK,OAAO,CAAC,EAAE,gBAAgB,KAAK,MAAM,CAAC;AAAA,MAClD;AAAA,IAAA;AAGF,UAAM,YAAiD;AAAA,MACrD,CAAC,aAAa,GAAG,GAAG,eAAe,KAAK;AAAA,MACxC,CAAC,aAAa,OAAO,GAAG,eAAe,SAAS;AAAA,MAChD,CAAC,aAAa,GAAG,GAAG,eAAe,KAAK;AAAA,MACxC,CAAC,aAAa,OAAO,GAAG,eAAe,SAAS;AAAA,MAChD,CAAC,aAAa,MAAM,GAAG,eAAe,QAAQ;AAAA,MAC9C,CAAC,aAAa,KAAK,GAAG,eAAe,OAAO;AAAA,MAC5C,CAAC,aAAa,MAAM,GAAG,eAAe,QAAQ;AAAA,MAC9C,CAAC,aAAa,OAAO,GAAG,eAAe,SAAS;AAAA,MAChD,CAAC,aAAa,IAAI,GAAG,eAAe,MAAM;AAAA,MAC1C,CAAC,aAAa,KAAK,GAAG,eAAe,OAAO;AAAA,MAC5C,CAAC,aAAa,MAAM,GAAG,eAAe,QAAQ;AAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnChD,SAAAC,iBAAA,MAAA,OAAA,SAGY;AAHZ,QAAA,OAAAC,eAAAC,WAAA,EAAA,OAAA,UAAA,MAAA,CAAA,CAAA,mBAAA;AAAAC,gBAAA,KAAA,QAAA,WAAA,CAAA,GAAA,MAAA,OAAA,OAAA;;;;;;;;;;;;;;;;;ACKA,UAAM,QAAQ;AAId,UAAM,OAAO,SAAS,MAAO,MAAM,cAAc,YAAY,SAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACT3D,IAAA,qCAAAC,sBAAL;AACLA,oBAAA,IAAK,IAAA;AACLA,oBAAA,IAAK,IAAA;AAFKA,SAAAA;AAAA,GAAA,oBAAA,CAAA,CAAA;ACIZ,MAAM,cAAc;AAAA,EAClB,CAAC,iBAAiB,EAAE,GAAG;AAAA,IACrB,MAAM,iBAAiB;AAAA,IACvB,OAAO;AAAA,EACT;AAAA,EACA,CAAC,iBAAiB,EAAE,GAAG;AAAA,IACrB,MAAM,iBAAiB;AAAA,IACvB,OAAO;AAAA,EACT;AACF;AAEa,MAAA,YAAY,CAAC,eAAe;AACjC,QAAA,WAAW,IAAI,KAAK;AAE1B,QAAM,cAAc,MAAM;AACxB,aAAS,QAAQ;AAAA,EAAA;AAGnB,QAAM,eAAe,MAAM;AACzB,aAAS,QAAQ;AAAA,EAAA;AAGnBN,mBAAe,YAAY,MAAM;AAClB;EAAA,CACd;AAEM,SAAA;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ;AC9Ba,MAAA,gBAAgB,YAAY,SAAS;AAAA,EAChD,OAAO,OAAoB;AAAA,IACzB,aAAa;AAAA,EAAA;AAAA,EAEf,SAAS,CAAC;AAAA,EACV,SAAS;AAAA,IACP,eAAe;AACb,WAAK,cAAc;AAAA,IACrB;AAAA,IACA,kBAAkB;AAChB,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AACF,CAAC;;;;;ACVK,UAAA,iBAAiB,IAAI,IAAI;AAC/B,UAAM,EAAE,aAAAO,cAAa,UAAU,aAAa,iBAC1C,UAAU,cAAc;AAC1B,UAAM,EAAE,QAAQ,UAAU,IAAI,QAAQ;AACtC,UAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRZ,MAAM,UAAU,MAAM;AACrB,QAAA,EAAE,MAAM;AAEd,QAAM,WAAW;AAAA,IACf;AAAA,MACE,OAAO,EAAE,6BAA6B;AAAA,MACtC,OAAO;AAAA,QACL;AAAA,UACE,OAAO,EAAE,+BAA+B;AAAA,UACxC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,4BAA4B;AAAA,UACrC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,8BAA8B;AAAA,UACvC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,6BAA6B;AAAA,UACtC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,8BAA8B;AAAA,UACvC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,OAAO,EAAE,8BAA8B;AAAA,MACvC,OAAO;AAAA,QACL;AAAA,UACE,OAAO,EAAE,gCAAgC;AAAA,UACzC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,4BAA4B;AAAA,UACrC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,8BAA8B;AAAA,UACvC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,OAAO,EAAE,4BAA4B;AAAA,MACrC,OAAO;AAAA,QACL;AAAA,UACE,OAAO,EAAE,8BAA8B;AAAA,UACvC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,QACA;AAAA,UACE,OAAO,EAAE,0BAA0B;AAAA,UACnC,MAAM,aAAa;AAAA,UACnB,MAAM,gBAAgB;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,IACA;AAAA,MACE,OAAO,EAAE,4BAA4B;AAAA,MACrC,OAAO;AAAA,QACL;AAAA,UACE,OAAO,EAAE,6BAA6B;AAAA,UACtC,MAAM,aAAa;AAAA,UACnB,MAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EAAA;AAGF,SAAO,EAAE,SAAS;AACpB;;;;;AC5EM,UAAA,aAAa,IAAI,KAAK;AAEtB,UAAA,EAAE,aAAa;AACrB,UAAM,aAAa;AAEnB,UAAM,gBAAgB,MAAM;AAC1B,iBAAW,QAAQ;AAAA,IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBd,MAAM,kBAAkB,MAAY;AAChC,EAAA,SAAA,KAAK,UAAU,IAAI,WAAW;AACzC;AAEO,MAAM,qBAAqB,MAAY;AACtC,QAAA,oBAAoB,KAAK;AAE3B,MAAA,SAAS,SAAS,WAAW,GAAG;AAClC,aAAS,OAAO,WAAW;AAAA,EAC7B;AACF;ACFa,MAAA,eAAe,YAAY,QAAQ;AAAA,EAC9C,OAAO,OAAmB;AAAA,IACxB,YAAY;AAAA,EAAA;AAAA,EAEd,SAAS,CAAC;AAAA,EACV,SAAS;AAAA,IACP,WAAW;AACT,WAAK,aAAa;AACF;IAClB;AAAA,IACA,YAAY;AACV,WAAK,aAAa;AACC;IACrB;AAAA,EACF;AACF,CAAC;;;;;ACnBD,UAAM,YAAY;AAClB,UAAM,aAAa;;;;;;;;;;;;;;;;;;;ACGb,UAAA,iBAAiB,IAAI,IAAI;AAC/B,UAAM,EAAE,aAAAA,cAAa,UAAU,aAAa,iBAC1C,UAAU,cAAc;AAC1B,UAAM,EAAE,QAAQ,UAAU,IAAI,QAAQ;AACtC,UAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLnB,UAAM,CAAC,YAAY,WAAW,IAAI,UAAU;AACtC,UAAA,EAAE,aAAa;AACrB,UAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAnB,UAAM,YAAY;AAClB,UAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJnB,UAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNnB,SAAAL,iBAAA,MAAA,OAAA,SAAA,QAAA;AAII,QAAA,OAAkCC,eAAAC,WAAA;AAAA,IAClC,OAAM;AAAA,IACN;IACA;IACA,SAAW;AAAA,IARf,MAAA;AAAA;;;;;;;;;;ACAA,SAAAF,iBAAA,MAAA,OAAA,SAAA,QAAA;AAII,QAAA,OAAkCC,eAAAC,WAAA;AAAA,IAClC,OAAM;AAAA,IACN;IACA;IACA,SAAW;AAAA,IARf,MAAA;AAAA;;;;;;;;;;ACAA,SAAAF,iBAAA,MAAA,OAAA,SAAA,QAAA;AAII,QAAA,OAAkCC,eAAAC,WAAA;AAAA,IAClC,OAAM;AAAA,IACN;IACA;IACA,SAAW;AAAA,IARf,MAAA;AAAA;;;;;;;;;;ACAA,SAAA,eAAA,MAAA,OAAA,SAAA,QAAA;AAII,QAAA,OAAkCD,eAAAC,WAAA;AAAA,IAClC,OAAM;AAAA,IACN;IACA;IACA,SAAW;AAAA,IARf,MAAA;AAAA;;;;;;;;;;;;;ACUA,UAAM,YAAW,oBAAI,KAAK,GAAE,YAAY;AAClC,UAAA,EAAE,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLd,MAAM,uBAAuB,MAAM;AACxC,QAAM,QAAQ;AACd,QAAM,aAAa;AAEnB;AAAA,IACE,MAAM,MAAM;AAAA,IACZ,CAAC,cAAc;AACb,UAAI,UAAU,SAAS,gBAAgB,MAAM,GAAG;AAC9C,mBAAW,aAAa;AAAA,MAAA,OACnB;AACL,mBAAW,gBAAgB;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,EAAE,WAAW,KAAK;AAAA,EAAA;AAEtB;AChBO,MAAM,wBAAwB,MAAM;AAC1B,YAAU;AACP,eAAa;AAUjC;;;;;ACRA,UAAM,WAAW,cAAc;AAAA,MAC7B,iBAAiB;AAAA,MACjB,qBAAqB;AAAA,MACrB,kBAAkB;AAAA,IAAA,CACnB;AAEO,YAAA;AAAA,MACN,WAAW;AAAA,QACT,MAAM,SAAS,MAAM,UAAW;AAAA,QAChC,KAAK,SAAS,MAAM,UAAU;AAAA,MAChC;AAAA,MACA,MAAM,CAAC,GAAI,SAAS,MAAM,QAAQ,CAAA,CAAG;AAAA,MACrC,MAAM,CAAC,GAAI,SAAS,MAAM,QAAQ,CAAA,CAAG;AAAA,IAAA,CACtC;AAEoB;AACC;;;;;;;;;;;;;;;;;;;;","x_google_ignoreList":[0,1,2]}